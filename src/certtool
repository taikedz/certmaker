#!/bin/bash

### Cert Tool Usage:help
#
# Tool to create a local CA, and create certificates for sites.
#
#
#
# Certificate Authority tools - run this where the CA should be. The config to use is the CA configuration.
#
#	 certtool create-ca --config=CONFIGFILE --ca=CANAME
#
#	 certtool sign --config=CONFIGFILE --csr=CSRFILE --ca=CANAME [--batch]
#
# The CA data is simply stored in a local directory ; you must be in the parent directory of the appropriate CA store to use it.
#
#
#
# Domain creator - you should run these on the hosts you are generating a key/cert pair for.
# Send the resulting CSR to the operator of the CA host
# The config to use is the domain configuration.
#
# Other than to determine the domains to certify, the FQDN is used to name the file as well, so they should not be renamed.
#
#	 certtool new-domain --config=CONFIGFILE --fqdn=FQDN
#
# The "domain" command is shorthand for executing the following two commands indpendently
#
#	 certtool create-key --config=CONFIGFILE --fqdn=FQDN
#
#	 certtool derive-csr --config=CONFIGFILE --fqdn=FQDN
#
###/doc

#%include out.sh args.sh autohelp.sh

set -euo pipefail

DRYRUN=false
KEYSIZE=4096

::() {
	out:info "$*"
	if [[ "$DRYRUN" = false ]]; then
		"$@"
	fi
}

get_ca_store_dir() {
	[[ -n "${caname:-}" ]] || out:fail "\$caname not specifed"

	storedir="${caname}-store"

	[[ ! -d "$storedir" ]] || return 0

	mkdir -p "$storedir"
}

create_ca_cert() {
	gen_custom_config
	get_ca_store_dir

	:: openssl req -x509 -config "$newconfig" -out "$storedir/${caname}-ca.cer" -outform PEM -keyout "$storedir/$caname.key" -newkey rsa:"$KEYSIZE" -sha256

	out:warn "You can store the certificate password in [$storedir/pass.txt] for automatic signing"
}

# Some test code for troubleshooting `passin` below
#tokens() { for thing in "$@"; do echo "<< $thing >>"; done ; }

sign_cert() {
	gen_custom_config
	get_ca_store_dir

	ensure_file "$storedir/index.txt"
	ensure_file "$storedir/serial.txt" '01'

	# Try to use the password file *only* when in batch mode
	if [[ -n "$batchmode" ]]; then
		# Note - the strange syntax for `passin` further below is ...
		#  ... well known. And looks butt-ugly.
		#  But needed.
		#  https://stackoverflow.com/questions/7577052/bash-empty-array-expansion-with-set-u
		local passfile="$storedir/pass.txt"
		local passin=()
		if [[ -f "$passfile" ]]; then
			passin=(-passin "file:$passfile")
		fi
	fi

	:: openssl ca $batchmode ${passin[@]+"${passin[@]}"} -config "$newconfig" -policy signing_policy -extensions signing_req -out "${csrfile%.*}-signed.cer" -infiles "$csrfile"
}

create_client_key() {
	gen_custom_config
	:: openssl genrsa -out "${fqdn}.key" "$KEYSIZE" -config "$newconfig"
}

derive_csr() {
	gen_custom_config
	:: openssl req -new -key "${fqdn}.key" -out "${fqdn}.csr" -config "$newconfig"
}

gen_custom_config() {
	newconfig="$(mktemp ./XXXX-"$(basename "$configfile")".tmp )"
	fqdn="${fqdn:-}"
	caname="${caname:-}"
	sed "
	s/%FQDN%/$fqdn/g
	s/%HOSTNAME%/${fqdn%%.*}/g
	s/%CANAME%/$caname/g
	" "$configfile" > "$newconfig"
}

ensure_file() {
	local target="$1"; shift
	local tdir="$(dirname "$target")"

	[[ -d "$tdir" ]] || mkdir -p "$tdir"

	[[ -f "$target" ]] || echo -n "$*" > "$target"
}

require_arg() {
	local flag="$1"; shift
	local target="$(args:get "$flag" "$@")"

	[[ -n "$target" ]] || out:fail "You need to specify [$flag]"

	echo "$target"
}

reqvar() {
	[[ -n "$*" ]] || exit 1
}

main() {
	autohelp:check "$@"
	[[ -n "$*" ]] || {
		autohelp:print
		exit 0
	}

	action="$1"; shift
	configfile="$(require_arg --config "$@")" ; reqvar "${configfile:-}"

	batchmode=''
	if args:has --batch "$@"; then
		batchmode=-batch
	fi

	case "$action" in
	create-ca)
		caname="$(require_arg --ca "$@")" ; reqvar "$caname"
		create_ca_cert
		;;
	new-domain)
		"$0" create-key "$@" || return 1
		"$0" derive-csr "$@" || return 1
		;;
	create-key)
		fqdn="$(require_arg --fqdn "$@")" ; reqvar "$fqdn"
		create_client_key
		;;
	derive-csr)
		fqdn="$(require_arg --fqdn "$@")" ; reqvar "$fqdn"
		derive_csr
		;;
	sign)
		caname="$(require_arg --ca "$@")" ; reqvar "$caname"
		csrfile="$(require_arg --csr "$@")" ; reqvar "$csrfile"
		sign_cert
		;;
	*)
		out:fail "Unkown action [$action]"
	esac

	if [[ -n "${newconfig:-}" ]] && [[ -f "$newconfig" ]]; then
		rm "$newconfig"
	fi
}

( # Allow the cleanup to run even on fail
main "$@"
) || rm ./*.cnf.tmp 2>/dev/null
