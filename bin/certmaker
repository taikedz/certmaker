#!/usr/bin/env bash

# This software is Free Software
# (C) Tai Kedzierski 2017-2018
#
# It is provided to you under the terms of the GNU General Public License v3
# https://www.gnu.org/licenses/gpl-3.0.html


### certmaker Usage:help
#
# Tool to generate a CA, generate keys and CSRs, and sign CSRs
#
# From https://github.com/taikedz/CertMaker
#
# Further below are /all/ the available commands, but you probably only want one of the following:
#
#   certmaker new ca
#   certmaker quick --edit
#   certmaker quick HOST DOMAIN ...
#   certmaker paths [HOST]
#   certmaker view CERTFILE
#
# Run
#
#   certmaker help
#
# for a quick-start tutorial.
#
#
# 
# ### Listing profiles
#
# List host profiles
#
#   certmaker paths
#
# List key and certificate for a host profile
#
#   certmaker paths HOST
#
#
# ### Creating and signing profiles
#
# Create a new host profile, edit it:
#
#     certmaker new host HOST
#     certmaker edit HOST
#
# Regenerate host profile assets
#
#   certmaker renew key { HOST | CONFIG [KEYFILE] }
#   certmaker renew csr { HOST | KEYFILE CONFIG [CSRFILE] }
#
# Sign a host profile or CSR file:
#
#     certmaker sign { HOST | CSRFILE [CERTFILE] }
#
#
# ### Generate new CA or templates
#
# Generate a new template configuration file
#
#   certmaker template { ca | host } [DESTFILE]
#
# Create a new CA:
#
#     certmaker new ca
#
# ### Certificate viewing and fetching
#
# Fetch a site's certificate, and view a certificate file
#
#   certmaker fetch { DOMAIN | URL }
#
#   certmake view CERTFILE
#
#
###/doc
cm:guide() {
cat <<'ENDOFEXTENDEDGUIDE' | less
CertMaker
===========

A tool to create an OpenSSL certificate authority, and generate certificates, for use on internal networks.

The tool is written with three uses cases in mind:

* As an *internal* CA tool that will act as CA and manage certificate/key pairs centrally, distributing them to target servers
    * the `quick` command facilitates this workflow
* As a *CSR client* tool for generating CSRs to be sent to CAs
* As a plain internal CA that can sign individual CSRs

If you are deploying a public-facing web site, please consider using [Let's Encrypt](https://letsencrypt.org)


Quick Start
===========

Setup

    sudo ./install.sh

    # Adjust the ca_distinguished_name section
    sudo certmaker new ca

    # Adjust the host template's server_distinguished_name section
    sudo certmaker quick --edit

Create host key and certificate

    sudo certmaker quick new-host myhost.net

Renew host certificate, print host asset paths

    sudo certmaker quick new-host
    certmaker paths new-host

Copy the assets to the target host.


Detailed walk-through
=====================


Install certmaker
-----------------

    sudo ./install.sh

Configuration is palced in `/etc/certmaker/certmaker.config`

If you do not install as root, it is placed in `~/.config/certmaker/certmaker.config`. Note that if a root installation already exists, you cannot install for a non-root user.

Ensure your `EDITOR` environment variable is set to your preferred text editor; if it is not set, CertMaker will try to use Emacs, nano, vim or vi.

Centrally managed hosts
-----------------------

New CA
---------

Sets up a new CA config, and opens an editor; specifically ensure you update the organisation country and details. You can also edit the `default_days` property to specify the number of days a newly signed certificate is valid for. You will be prompted for a password for the key.

    certmaker new ca

It is possible to save a password file in plaintext in `$CERTMAKERCONFIG/ca/pass.txt` to allow running in batch mode; treat this with caution as this means that your password will be lying in plain text on the filesystem.

If your CA is going to be used to centrally manage certificates and keys, set up a generic hosts config which will be used as a template for managed hosts

    certmaker quick --edit


Centrally managed hosts
-----------------------

If you want the CA to manage both keys and certificates for host machines, use these steps. In this scenario, the CA is responsible for creating both the keys and the certificates that will be placed on host machines.

Create a new host profile, specifying the domains to certify for - you will be prompted to edit it, and will then be given paths to a key and certificate file as a result.

    certmaker quick myhost DOMAIN ...

Re-run the command any time you want to renew the certificate. You will need to copy the new certificate to the desired host machine to replace the old certificate.

If you want to add new domains, you will need to edit the host config and add them manually, then re-generate the signed certificate:

    certmaker edit myhost
    certmaker quick myhost

Generic CSR and CA activities
-----------------------------

###    Target host

If you simply want to create a CSR for your machine, to send to a remote CA for signing:

Create a configuration for the CSR, and edit it

    certmaker template host myhost.cnf
    nano myhost.cnf

If you don't already have a key, create one form the config

    certmaker renew key myhost.cnf

Finally, create the CSR

    certmaker renew csr key-file.key myhost.cnf

This will create a CSR file `myhost.csr` to send to the CA


###    Certificate Authority

On receipt of a CSR, simply use the `sign csr` command:

    certmaker sign csr CSRFILE [OUTCERTFILE]

This will generate a certificate file as specified, or with the same base name as the CSR, to send back to the requestor.



Sub Commands
============


fetch/view - to retrieve and inspect certificates
-------------------------------------------------

###    `fetch`

You can fetch the certificate of a live site using

    certmaker fetch URL

Supported URLs include `https://`, `ldaps://` and `ftps://`

###    `view`

You can inspect the contents of a certificate PEM file (typically a block of base-64 data bounded with `BEGIN` and `END` statements) using

    certmaker view CERTFILE

Certificates generated by CertMaker are always PEM files.



jks - Java Keystore and PKCS12 store manipulation
-------------------------------------------------

You can manipulate a Java Key Store or PKCS12 key store using the `jks` subcommand.


When transferring a Key and Certificate pair to a Java target, you should hand off a PKCS12 file ratherm than PEM files

    certmaker jks generate -k generatedkeys.p12 -a defaultalias -f KEYFILE


You can then load the key into the Java host's keystore using

    certmaker jks add-key -k KEYSTORE -a ALIAS -f generatedkeys.p12


You can view a keystore contents using

    certmaker jks view -k KEYSTORE [-a ALIAS]

See `certmaker jks --help` for more info and commands.
ENDOFEXTENDEDGUIDE
}
### Certificate Getter Usage:cert-getter
#
# Certificate fetch and view agent.
#
#     certmaker fetch [SCHEME://]DOMAIN[:PORT]
#     certmaker view CERTFILE
#
# Fetch the certificate for a HTTPS domain to a file, or view the contents of a certificate file
#
# DOMAIN is the domain name to check, by default on port 443
#
# You can specify an alternative port, for example
#
#     certmaker fetch mydomain.net:8443
#
###/doc

##bash-libs: out.sh @ 75ff4139 (1.1)

##bash-libs: colours.sh @ 75ff4139 (1.1)

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo -e "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour")
#
# Requires processing of escape characters.
#
# Colours available:
#
# CRED, CBRED, HLRED -- red, bold red, highlight red
# CGRN, CBGRN, HLGRN -- green, bold green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bold yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bold blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bold purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bold teal, highlight teal
#
# CDEF -- switches to the terminal default
# CUNL -- add underline
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
# If the session is detected as being in a pipe, colours will be turned off.
#   You can override this by calling `colours:check --color=always` at the start of your script
#
###/doc

##bash-libs: tty.sh @ 75ff4139 (1.1)

tty:is_ssh() {
    [[ -n "$SSH_TTY" ]] || [[ -n "$SSH_CLIENT" ]] || [[ "$SSH_CONNECTION" ]]
}

tty:is_pipe() {
    [[ ! -t 1 ]]
}

### colours:check ARGS Usage:bbuild
#
# Check the args to see if there's a `--color=always` or `--color=never`
#   and reload the colours appropriately
#
###/doc
colours:check() {
    if [[ "$*" =~ --color=always ]]; then
        COLOURS_ON=true
    elif [[ "$*" =~ --color=never ]]; then
        COLOURS_ON=false
    fi

    colours:define
    return 0
}

colours:auto() {
    if tty:is_pipe ; then
        COLOURS_ON=false
    else
        COLOURS_ON=true
    fi

    colours:define
    return 0
}

colours:define() {
    if [[ "$COLOURS_ON" = false ]]; then

        export CRED=''
        export CGRN=''
        export CYEL=''
        export CBLU=''
        export CPUR=''
        export CTEA=''

        export CBRED=''
        export CBGRN=''
        export CBYEL=''
        export CBBLU=''
        export CBPUR=''
        export CBTEA=''

        export HLRED=''
        export HLGRN=''
        export HLYEL=''
        export HLBLU=''
        export HLPUR=''
        export HLTEA=''

        export CDEF=''

    else

        export CRED=$(echo -e "\033[0;31m")
        export CGRN=$(echo -e "\033[0;32m")
        export CYEL=$(echo -e "\033[0;33m")
        export CBLU=$(echo -e "\033[0;34m")
        export CPUR=$(echo -e "\033[0;35m")
        export CTEA=$(echo -e "\033[0;36m")

        export CBRED=$(echo -e "\033[1;31m")
        export CBGRN=$(echo -e "\033[1;32m")
        export CBYEL=$(echo -e "\033[1;33m")
        export CBBLU=$(echo -e "\033[1;34m")
        export CBPUR=$(echo -e "\033[1;35m")
        export CBTEA=$(echo -e "\033[1;36m")

        export HLRED=$(echo -e "\033[41m")
        export HLGRN=$(echo -e "\033[42m")
        export HLYEL=$(echo -e "\033[43m")
        export HLBLU=$(echo -e "\033[44m")
        export HLPUR=$(echo -e "\033[45m")
        export HLTEA=$(echo -e "\033[46m")

        export CDEF=$(echo -e "\033[0m")

    fi
}

colours:auto

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'true' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'true' to enable command echoing
#
###/doc

: ${MODE_DEBUG=false}
: ${MODE_DEBUG_VERBOSE=false}

# Internal
function out:buffer_initialize {
    OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "true"
###/doc
function out:debug {
    if [[ "$MODE_DEBUG" = true ]]; then
        echo "${CBBLU}DEBUG: $CBLU$*$CDEF" 1>&2
    fi
}

### out:debug:fork [MARKER] Usage:bbuild
#
# Pipe the data coming through stdin to stdout
#
# If debug mode is on, *also* write the same data to stderr, each line preceded by MARKER
#
# Insert this debug fork into pipes to see their output
#
###/doc
function out:debug:fork {
    if [[ "$MODE_DEBUG" = true ]]; then
        local MARKER="${1:-DEBUG: }"; shift || :

        cat - | sed -r "s/^/$MARKER/" | tee -a /dev/stderr
    else
        cat -
    fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
    echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
    echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
    OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
    [[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

    [[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

    for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
        "$@" "$buffer_line"
    done

    out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
    local ERCODE=127
    local numpat='^[0-9]+$'

    if [[ "$1" =~ $numpat ]]; then
        ERCODE="$1"; shift || :
    fi

    echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
    exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
    echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

### out:dump Usage:bbuild
#
# Dump stdin contents to console stderr. Requires debug mode.
#
# Example
#
# 	action_command 2>&1 | out:dump
#
###/doc

function out:dump {
    echo -n "${CBPUR}$*" 1>&2
    echo -n "$CPUR" 1>&2
    cat - 1>&2
    echo -n "$CDEF" 1>&2
}

### out:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires MODE_DEBUG set to true
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Press return to continue execution.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
###/doc

function out:break {
    [[ "$MODE_DEBUG" = true ]] || return 0

    echo -en "${CRED}BREAKPOINT: $* >$CDEF " >&2
    read
    if [[ "$REPLY" =~ quit|exit|stop ]]; then
        out:fail "ABORT"
    fi
}

if [[ "$MODE_DEBUG_VERBOSE" = true ]]; then
    set -x
fi
##bash-libs: autohelp.sh @ 75ff4139 (1.1)

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#    ### <title> Usage:help
#    #
#    # <some content>
#    #
#    # end with "###/doc" on its own line (whitespaces before
#    # and after are OK)
#    #
#    ###/doc
#
# You can set a different help section by specifying a subsection
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
#
###/doc

HELPCHAR='#'

function autohelp:print {
    local SECTION_STRING="${1:-}"; shift || :
    local TARGETFILE="${1:-}"; shift || :
    [[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
    [[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
                echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
    echo ""
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
function autohelp:paged {
    : ${PAGER=less}
    autohelp:print "$@" | $PAGER
}

### autohelp:check Usage:bbuild
#
# Automatically print help and exit if "--help" is detected in arguments
#
# Example use:
#
#    #!/bin/bash
#
#    ### Some help Usage:help
#    #
#    # Some help text
#    #
#    ###/doc
#
#    #%include autohelp.sh
#
#    main() {
#        autohelp:check "$@"
#
#        # now add your code
#    }
#
#    main "$@"
#
###/doc
autohelp:check() {
    if [[ "$*" =~ --help ]]; then
        cols="$(tput cols)"
        autohelp:print | fold -w "$cols" -s || autohelp:print
        exit 0
    fi
}
##bash-libs: runmain.sh @ 75ff4139 (1.1)

### runmain SCRIPTNAME FUNCTION [ARGUMENTS ...] Usage:bbuild
#
# Runs the function FUNCTION with ARGUMENTS, only if the runtime
# name of the script matches SCRIPTNAME
#
# This allows you include a main-like function in your library
# that only runs if you use your lib as an executabl itself.
#
# For example, an image archiver could be:
#
# 	function archive_images {
# 		tar czf "$1.tgz" "$@"
# 	}
#
# 	runmain archiveimages.sh archive_images "$@"
#
# When included a different script, the runmain call does not fire the lib's function
#
# If the lib is compiled/made executable, and named "archiveimages.sh", the function runs.
#
# This is similar to `if __name__ == "__main__"` clauses in python
#
###/doc

function runmain {
    local required_name="$1"; shift || :
    local funcall="$1"; shift || :
    local scriptname="$(basename "$0")"

    if [[ "$required_name" = "$scriptname" ]]; then
        "$funcall" "$@"
    fi
}

function argcheck {
    local arg="$1"; shift

    if [[ -z "$arg" ]]; then
        out:fail "Please specify $*"
    fi
}

function view_cert {
    [[ -f "$1" ]] || out:fail "No such file [$1]"

    if grep -qP "BEGIN( NEW)? CERTIFICATE REQUEST" "$1"; then
        openssl req -text -noout -verify -in "$1"

    else
        openssl x509 -text -noout -in "$1"
    fi
}

function fetch_cert {
    local connectstring="$domain:$port"

    if [[ -f "$connectstring" ]]; then
        echo "$connectstring"
        return
    fi

    echo | (set -x ; openssl s_client -servername "$domain" -connect "$connectstring" ) | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > "$tmpcert" || out:fail "Could not connect to [$domain] on [$port]"
}

function determine_port_from_scheme {
    [[ -n "${scheme:-}" ]] || {
        port=443
        return 0
    }

    case "$scheme" in
    https)
        port=443 ;;
    ssh)
        port=22 ;;
    ldaps)
        port=636 ;;
    ftps)
        port=990 ;;
    *)
        out:fail "Cannot extrapolate port for $scheme" ;;
    esac
}

function get_port() {
    if [[ "$domain" =~ ^(.+?):([0-9]+)$ ]]; then
        port="${BASH_REMATCH[2]}"
        domain="${BASH_REMATCH[1]}"
    fi

    if [[ -z "${port:-}" ]]; then
        determine_port_from_scheme
    fi
}

function get_domain_and_scheme {
    domain="$target"
    [[ ! -f "$target" ]] || out:fail "[$target] is a file"

    # Blat scheme and path
    if [[ "$domain" =~ ^([a-zA-Z0-9]+):// ]]; then
        scheme="${BASH_REMATCH[1]}"
        domain="${domain#$scheme://}"
        domain="${domain%%/*}"
    fi
}

cert-getter:main() {
    if [[ "$*" =~ --help ]]; then
    	autohelp:print cert-getter
	exit 0
    fi

    local action="${1:-}"; shift || out:fail "Please specify an aciton view or fetch"
    local target="${1:-}"; shift || out:fail "Please specify a target file or domain"

    argcheck "$action" "action (view|fetch)"
    argcheck "$target" "URL or cert file"

    case "$action" in
    fetch)
        get_domain_and_scheme
        get_port
        tmpcert="${domain}-fetched.cer"
        fetch_cert
        ;;
    view)
        view_cert "$target"
        ;;
    *)
        out:fail Invalid action
        ;;
    esac
}

runmain cert-getter.sh cert-getter:main "$@"

##bash-libs: safe.sh @ 75ff4139 (1.1)

### Safe mode Usage:bbuild
#
# Set safe mode options
#
# * Script bails on error
# * Accessing a variable that is not set is an error
# * If a file glob does not expand, cause an error condition
# * If a component of a pipe fails, the entire pipe is a failure
#
###/doc

set -eufo pipefail
##bash-libs: searchpaths.sh @ 75ff4139 (1.1)


# FIXME - set function signature in head of help
### searchpaths:file_from PATHDEF FILE Usage:bbuild
#
# Locate a file along a search path.
#
# EXAMPLE
#
# The following will look for each of the files
#  in order of preference of a local lib directory, a profile-wide one, then a system-
#  wide one.
#
#    MYPATH="./lib:$HOME/.local/lib:/usr/local/lib"
# 	searchpaths:file_from "$MYPATH" file
#
# Echoes the path of the first file found.
#
# Returns 1 on failure to find any file.
#
###/doc

function searchpaths:file_from {
    local PATHS="$1"; shift || :
    local FILE="$1"; shift || :

    out:debug "Looking for file [$FILE] amongst [$PATHS]"

    for path in $(echo "$PATHS"|tr ':' ' '); do
        out:debug "Try path: $path"
        local fpath="$path/$FILE"
        if [[ -f "$fpath" ]]; then
            echo "$fpath"
            return 0
        else
            out:debug "No $fpath"
        fi
    done
    return 1
}
##bash-libs: vars.sh @ 75ff4139 (1.1)

### Vars library Usage:bbuild
#
# Functions for checking variables
#
###/doc

### vars:require VARNAME ... Usage:bbuild
#
# Check a list of environment variables such that none are non-empty.
#
# If variables are empty/not set, the name is echoed.
#
# Returns the number of missing variables.
#
#    myvarA=one
#    myvarB=
#    myvarC=three
#
#    missing="$(vars:require myvarA myvarB myvarC)"
#
#    if [[ -n "$missing" ]]; then
#        out:fail "Variables were not set : [$missing]"
#    fi
#
###/doc

vars:require() {
    local missing=(:)

    for varname in "$@"; do
        echo "[[ -n "\$$varname" ]]" | bash || {
            missing[${#missing[@]}]="$varname"
        }
    done

    missing=("${missing[@]:1}")

    echo "${missing[*]}"
    return "${#missing[@]}"
}

CERTMAKER_confpaths=".:$HOME/.config/certmaker:/etc/certmaker"

cm:config:load_config() {
	local conffile="$(searchpaths:file_from "$CERTMAKER_confpaths" certmaker.config)"

	if [[ -z "$conffile" ]]; then
		out:fail "No config file found."
	fi

	. "$conffile"
}

cm:config:get_temp() {
    echo "$cnftemplates/$1.cnf"
}

### certmaker template {ca|host} [OUTFILE] Usage:template
#
# Create an OpenSSL config file for a CA or a host
#
###/doc

cm:template() {
    cm:helpcheck template "$@"

    local fromfile target outfile
    target="$1"; shift
    outfile="${1:-}"; shift || :

    case "$target" in
    ca|host)
        fromfile="$(cm:config:get_temp "$target")"
        [[ -n "${outfile:-}" ]] || outfile="./$(basename "$fromfile")"

        sed "
        s|%CASTOREDIR%|$castore|
        " "$fromfile" > "$outfile"
        ;;
    *)
        out:fail "No template for $target"
        ;;
    esac
}
##bash-libs: bincheck.sh @ 75ff4139 (1.1)

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
    local BINEXE=
    for binname in "$@"; do
        # Some implementations of `which` print error messages
        # Not useful here.
        BINEXE=$(which "$binname" 2>/dev/null)

        if [[ -n "$BINEXE" ]]; then
            echo "$BINEXE"
            return 0
        fi
    done
    return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
    [[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
    local binname="$1"; shift || :

    [[ "$binname" =~ / ]] && { 
        # A relative path cannot be resolved, just check existence
        [[ -e "$binname" ]] && echo "$binname" || return 1

    } || binname="$(which "$binname" 2>/dev/null)"

    # `which` failed
    [[ -n "$binname" ]] || return 1

    [[ -h "$binname" ]] && {

        local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
        bincheck:path "$pointedname" ; return "$?"
    
    } || echo "$binname"
}

::() {
    [[ -n "$*" ]] || out:fail "No command specified"

	echo  "${CBTEA}$*${CDEF}"

	if [[ "${DRYRUN:-}" != true ]]; then
		"$@" || out:fail "$?"
	fi
}

# Attempt to use a default editor
# 
# If EDITOR is not set,
#  first try emacs - if present, it was probably deliberately installed
#  then try to use the easiest editor (nano)
#  then try to use vim
#  finally fallback to vi
cm:util:edit() {
    local editor
	if [[ -z "${EDITOR:-}" ]]; then
        for editor in nano emacs vim vi; do 
            if bincheck:has "$editor"; then
                EDITOR="$(which "$editor")"
            fi
        done
    fi

	"$EDITOR" "$1"
}

### New Certificate Authority Usage:new-ca
#
# Create and manage a certificate authority
#
# 	certmaker new ca
#
# Ensure you have a `keysize` and `hashalgorithm` entry in your certmaker config
#
# If in doubt, use
#
# 	keysize=4096
# 	hashalgorithm=sha256
#
###/doc

cm:ca:new-ca() {
	cm:helpcheck new-ca "$@" .

	[[ ! -e "$castore" ]] || out:fail "'$castore' must not exist. Archive the existing directory, and try again."

	mkdir -p "$castore"
	chmod 700 "$castore"

	cm:template ca "$castore/authority.cnf"

    cm:util:edit "$castore/authority.cnf"

	:: openssl req -x509 -config "$castore/authority.cnf" -out "$castore/authority.cer" -outform PEM -keyout "$castore/authority.key" -newkey rsa:"$keysize" -"$hashalgorithm"

	out:info "You can store the certificate password in [$castore/pass.txt] for automatic signing"
}
##bash-libs: askuser.sh @ 75ff4139 (1.1)

### askuser Usage:bbuild
# Present the user with questions on stderr
###/doc


yespat='^(yes|YES|y|Y)$'
numpat='^[0-9]+$'
rangepat='[0-9]+,[0-9]+'
listpat='^[0-9 ]+$'
blankpat='^ *$'

### askuser:confirm Usage:bbuild
# Ask the user to confirm a closed question. Defaults to no
#
# returns 0 on successfully match 'y' or 'yes'
# returns 1 otherwise
###/doc
function askuser:confirm {
    read -p "$* [y/N] > " 1>&2
    if [[ "$REPLY" =~ $yespat ]]; then
        return 0
    else
        return 1
    fi
}

### askuser:ask Usage:bbuild
# Ask the user to provide some text
#
# Echoes out the entered text
###/doc
function askuser:ask {
    read -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:password Usage:bbuild
# Ask the user to enter a password (does not echo what is typed)
#
# Echoes out the entered text
###/doc
function askuser:password {
    read -s -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:choose_multi Usage:bbuild
# Allows the user to choose from multiple choices
#
# askuser:chose_multi MESG CHOICESTRING
#
#
# MESG is a single string token that will be displayed as prompt
#
# CHOICESTRING is a comma-separated, or newline separated, or "\\n"-separated token string
#
# Equivalent strings include:
#
# * `"a\\nb\\nc"` - quoted and explicit newline escapes
# * `"a,b,c"` - quoted and separated with commas
# * `a , b , c` - not quoted, separated by commas
# * `a`, `b` and `c` on their own lines
#
# User input:
#
# User can choose by selecting
#
# * a single item by number
# * a range of numbers (4,7 for range 4 to 7)
# * or a string that matches the pattern
#
# All option lines that match will be returned, one per line
#
# If the user selects nothing, then function returns 1 and an empty stdout
###/doc
function askuser:choose_multi {
    local mesg=$1; shift || :
    local choices=$(echo "$*"|sed -r 's/ *, */\n/g')
    out:debug "CHOICES: $choices"

    out:info "$mesg:" 
    local choicelist="$(echo -e "$choices"|egrep '^' -n| sed 's/:/: /')"
    echo "$choicelist" 1>&2
    
    local sel=$(askuser:ask "Choice")
    if [[ "$sel" =~ $blankpat ]]; then
        return 1

    elif [[ "$sel" =~ $numpat ]] || [[ "$sel" =~ $rangepat ]]; then
        out:debug "Number choice [$sel]"
        echo -e "$choices" | sed -n "$sel p"
    
    elif [[ "$sel" =~ $listpat ]]; then
        echo "$choicelist" | egrep "^${sel// /|}:" | sed -r 's/^[0-9]+: //'

    else
        out:debug "Pattern choice [$sel]"
        echo -e "$choices"  |egrep "$(echo "$sel"|tr " " '|')"
    fi
    return 0
}

### askuser:choose Usage:bbuild
# Ask the user to choose an item
#
# Like askuser:choose_multi, but will loop if the user selects more than one item
#
# If the user provides no entry, returns 1
#
# If the user chooses one item, that item is echoed to stdout
###/doc
function askuser:choose {
    local mesg=$1; shift || :
    while true; do
        local thechoice="$(askuser:choose_multi "$mesg" "$*")"
        local lines=$(echo -n "$thechoice" | grep '$' -c)
        if [[ $lines = 1 ]]; then
            echo "$thechoice"
            return 0
        elif [[ $lines = 0 ]]; then
            return 1
        else
            out:warn "Too many results"
        fi
    done
}

### CSR Signing Usage:sign
#
# Sign a known host or csr
#
# 	certmaker sign host HOSTNAME
#
# 	certmaker sign csr CSRFILE
#
###/doc

cm:sign() {
	cm:helpcheck sign "$@"
	
	local target="${1:-}"; shift || out:fail "Specify target to sign"

    if [[ -f "$target" ]]; then
		cm:sign:csr "$target" "$@"
    else
		cm:sign:host "$target" "$@"
    fi
}

cm:sign:csr() {
	local csrfile certfile opssl_opts passfile passin
	csrfile="$1"; shift
	certfile="${csrfile%.*}.cer"

	cm:sign:overwrite_check "$certfile"

	files:ensure_file "$castore/index.txt"
	files:ensure_file "$castore/serial.txt" '01'

    passfile="$castore/pass.txt"

    opssl_opts=( -config "$castore/authority.cnf" -policy signing_policy -extensions signing_req -out "$certfile" -infiles "$csrfile")

	# Switch to batch mode when password file exists
    if [[ -f "$passfile" ]]; then
        :: openssl ca -batch -passin "file:$passfile" "${opssl_opts[@]}"
    else
        :: openssl ca "${opssl_opts[@]}"
    fi
}

cm:sign:host() {
    local host_name hostd
    host_name="$1"; shift
    hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "No such host profile '$host_name'"

    cm:sign:csr "$hostd/$host_name.csr" "$hostd/$host_name.cer"
}

cm:sign:overwrite_check() {
	local certfile="$1"; shift
	
	[[ -f "$certfile" ]] || return 0

	askuser:confirm "${CYEL}Overwrite '$certfile'?$CDEF" || out:fail "Abort."

	rm "$certfile" || out:fail "Could not remove '$certfile'"
}


files:ensure_file() {
	local target="$1"; shift
	local tdir="$(dirname "$target")"

	[[ -d "$tdir" ]] || mkdir -p "$tdir"

	[[ -f "$target" ]] || echo -n "$*" > "$target"
}

### New registered host Usage:new-host
#
# Create a new stored host for certfiying
#
# Generates a key + CSR pair stored against the name
#
# 	certmaker new host HOST
#
###/doc

cm:host:new-host() {
	cm:helpcheck new-host "$@"

	if [[ -z "$*" ]]; then
		out:fail "You need to specify a name for the host configuration. Try adding '--help'"
	fi

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ "$myhost" =~ ^[a-zA-Z0-9_.-]+$ ]] || out:fail "Host name can only contain letters, numbers, underscore, period and dash."

	[[ ! -d "$myhostd" ]] || out:fail "Host '$myhost' already exists."

	mkdir -p "$myhostd"

	cm:template host "$myhostd/$myhost.cnf"
}
### New entity Usage:new
#
# Create a new Certificate Authority, or Host
#
#   certmaker new host HOSTNAME
#
#   certmaker new ca CACONF
#
# You can generate a CACONF file with
#
#   certmaker template ca [CACONF]
#
###/doc

cm:new() {
    cm:helpcheck new "$@"

	local target="$1"; shift

	case "$target" in
	ca)
		cm:ca:new-ca "$@"
		;;
	host)
		cm:host:new-host "$@"
		;;
	*)
		out:fail "Unknown target for new: '$target'"
		;;
	esac
}
### CSR Regenration Usage:renew
#
# (Re-)generate key for the host or config.
#
#	certmaker renew key CONFIG [KEYFILE]
#	certmaker renew key HOST
#
# (Re-)generate CSR for the host or key+config file pair
#
#	certmaker renew csr KEYFILE CONFIG [CSRFILE]
#	certmaker renew csr HOST
#
###/doc

cm:renew() {
    cm:helpcheck renew "$@"

    local rtype="${1:-}" ; shift || out:fail "Specify renewal type"
    local filehost="${1:-}" ; shift || out:fail "Specify target file or host"

    case "$rtype" in
    csr|key)
        if [[ -f "$filehost" ]]; then
            cm:renew:${rtype}-file "$filehost" "$@"
        else
            cm:renew:${rtype}-host "$filehost" "$@"
        fi
        ;;
    *)
        out:fail "Unknown renewal type '$rtype'"
        ;;
    esac
}

cm:renew:key-file() {
    local config keyfile

    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"
    keyfile="${1:-}"; shift || {
        keyfile="${config%.*}.key"
    }

    :: openssl genrsa -out "$keyfile" "$keysize" -config "$config"
}

cm:renew:key-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:key-file "$hostd/${host_name}.cnf" "$hostd/${host_name}.key"
}

cm:renew:csr-file() {
    local keyfile csrfile config
    keyfile="${1:-}"; shift || out:fail "Specify an input key file"
    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"

    csrfile="${1:-}"; shift || {
        csrfile="${keyfile%.*}.csr"
    }

    :: openssl req -new -key "$keyfile" -out "$csrfile" -config "$config"
}

cm:renew:csr-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:csr-file "$hostd/${host_name}.key" "$hostd/${host_name}.cnf" "$hostd/${host_name}.csr"
}
cm:paths() {
    local host_name hostd

    host_name="${1:-}"; shift || {
        cm:paths:list
        return
    }

    hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "Unknown host profile '$host_name'"

    ls "$hostd/$host_name."{key,cer}
}

cm:paths:list() {
    find "$hoststore" -name '*.cnf' -exec dirname {} \; | sed "s|$hoststore/||"
}
### Quick mode Usage:quick
#
# Set up a base configuration for host certificates; don't add any `DNS.*` entries yet
#
#    certmaker quick --edit
#
# Once you have a base configuration, you can create any number of individual hosts
#
#   certmaker quick PROFILENAME DOMAINS ...
#
# The profile name is a name for the store of the config, key, CSR and certificate files.
#
# DOMAINS ... is only required when first creating the profile ; to subsequently edit the domains the certificate will certify for, run
#
#   certmaker edit PROFILENAME
#
#
###/doc

cm:quick() {
    cm:helpcheck quick "$@"

    if [[ "$1" = "--edit" ]]; then
        cm:quick:edit_template

    else
        cm:quick:host "$@"
    fi
}

cm:quick:edit_template() {
    local quick_template
    quick_template="$hoststore/quick.cnf"
    if [[ ! -f "$quick_template" ]]; then
        cm:template host "$quick_template"
    fi

    cm:util:edit "$quick_template"
}

cm:quick:host() {
    local host_name
    host_name="${1:-}"; shift || out:fail "Specify a host name"

    cm:quick:ensure_host "$host_name" "$@"

    cm:quick:ensure_key "$host_name"
    cm:renew:csr-host "$host_name"

    cm:sign:host "$host_name"

    # Echo the colour byte to stderr
    # but the keys to stdout
    # in case user is grepping for the files
    echo -n "$CBBLU" >&2
    echo "$(cm:paths "$host_name")"
    echo -n "$CDEF" >&2
}

cm:quick:ensure_host() {
    local host_name hostd hostconf quick_template x
    host_name="${1:-}"; shift
    hostd="$hoststore/$host_name"
    hostconf="$hostd/$host_name.cnf"

    quick_template="$hoststore/quick.cnf"
    [[ -f "$quick_template" ]] || out:fail "Quick template not yet set - run 'certmaker quick --edit' to create a global template first"

    if [[ ! -f "$hostconf" ]]; then

        askuser:confirm "Create host '$host_name' ?"
        [[ -n "$*" ]] || out:fail "You need to also specify domains to add."

        cm:host:new-host "$host_name"
        cp "$quick_template" "$hostconf"

        cm:quick:enumerate "$@" >> "$hostconf"
    fi
}

cm:quick:enumerate() {
    for x in $(seq 1 $#); do
        echo "DNS.$x = $1"
        shift
    done
}

cm:quick:ensure_key() {
    local host_name hostd hostconf
    host_name="${1:-}"; shift
    hostd="$hoststore/$host_name"

    if [[ ! -f "$hostd/$host_name.key" ]]; then
        cm:renew:key-host "$host_name"
    fi
}

### Edit host config Usage:edit
#
#	certmaker edit HOST
#
# Edit the SSL config for the registered host
#
###/doc

cm:edit() {
	cm:helpcheck edit "$@"

    if [[ "$1" = --ca ]]; then
        cm:util:edit "$castore/authority.cnf"
    else
        cm:edit:host "$@"
    fi
}

cm:edit:host() {

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ -d "$myhostd" ]] || out:fail "Host '$myhost' does not exist."

    cm:util:edit "$myhostd/$myhost.cnf"
}
cm:csr() {
	local name

	name="${1:-}"; shift || out:fail "Specify the base name to create e.g. 'mysite'"

	[[ -f "$name.cnf" ]] || {
		[[ -n "$*" ]] || out:fail "Specify the websites to certify for (FQDNs, e.g. 'mysite.company.net')"

		cm:template host "$name.cnf"
		cm:quick:enumerate "$@" >> "$name.cnf"
		cm:util:edit "$name.cnf"
	}
	[[ -f "$name.key" ]] || cm:renew key "$name.cnf" "$name.key"
	
	cm:renew csr "$name.key" "$name.cnf" "$name.csr"
}
#!/bin/bash

##bash-libs: args.sh @ 75ff4139 (1.1)

##bash-libs: patterns.sh @ 75ff4139 (1.1)

### Useful patterns Usage:bbuild
#
# Some useful regex patterns, exported as environment variables.
#
# They are not foolproof, and you are encouraged to improve upon them.
#
# $PAT_blank - detects whether an entire line is empty or whitespace
# $PAT_comment - detects whether is a line is a script comment (assumes '#' as the comment marker)
# $PAT_num - detects whether the string is an integer number in its entirety
# $PAT_cvar - detects if the string is a valid C variable name
# $PAT_filename - detects if the string is a safe UNIX or Windows file name;
#   does not allow presence of whitespace or special characters aside from '_', '.', '-'
# $PAT_email - simple heuristic to determine whether a string looks like a valid email address
#
###/doc

export PAT_blank='^\s*$'
export PAT_comment='^\s*(#.*)?$'
export PAT_num='^[0-9]+$'
export PAT_cvar='^[a-zA-Z_][a-zA-Z0-9_]*$'
export PAT_filename='^[a-zA-Z0-9_.-]$'
export PAT_email="$PAT_filename@$PAT_filename.$PAT_cvar"

### args Usage:bbuild
#
# An arguments handling utility.
#
###/doc

### args:get TOKEN ARGS ... Usage:bbuild
#
# Given a TOKEN, find the argument value
#
# Typically called with the parent's arguments
#
# 	args:get --key "$@"
# 	args:get -k "$@"
#
# If TOKEN is an int, returns the argument at that index (starts at 1, negative numbers count from end backwards)
#
# If TOKEN starts with two dashes ("--"), expect the value to be supplied after an equal sign
#
# 	--token=desired_value
#
# If TOKEN starts with a single dash, and is a letter or a number, expect the value to be the following token
#
# 	-t desired_value
#
# Returns 1 if could not find anything appropriate.
#
###/doc

function args:get {
    local seek="$1"; shift || :

    if [[ "$seek" =~ $PAT_num ]]; then
        local arguments=("$@")

        # Get the index starting at 1
        local n=$((seek-1))
        # but do not affect wrap-arounds
        [[ "$n" -ge 0 ]] || n=$((n+1))

        echo "${arguments[$n]}"

    elif [[ "$seek" =~ ^--.+ ]]; then
        args:get_long "$seek" "$@"

    elif [[ "$seek" =~ ^-[a-zA-Z0-9]$ ]]; then
        args:get_short "$seek" "$@"

    else
        return 1
    fi
}

function args:get_short {
    local token="$1"; shift || :
    while [[ -n "$*" ]]; do
        local item="$1"; shift || :

        if [[ "$item" = "$token" ]]; then
            echo "$1"
            return 0
        fi
    done
    return 1
}

function args:get_long {
    local token="$1"; shift || :
    local tokenpat="^$token=(.*)$"

    for item in "$@"; do
        if [[ "$item" =~ $tokenpat ]]; then
            echo "${BASH_REMATCH[1]}"
            return 0
        fi
    done
    return 1
}

### args:has TOKEN ARGS ... Usage:bbuild
#
# Determines whether TOKEN is present on its own in ARGS
#
# Typically called with the parent's arguments
#
# 	args:has thing "$@"
#
# Returns 0 on success for example
#
# 	args:has thing "one" "thing" "or" "another"
#
# Returns 1 on failure for example
#
# 	args:has thing "one thing" "or another"
#
# "one thing" is not a valid match for "thing" as a token.
#
###/doc

function args:has {
    local token="$1"; shift || :
    for item in "$@"; do
        if [[ "$token" = "$item" ]]; then
            return 0
        fi
    done
    return 1
}

### args:after TOKEN ARGS ... Usage:bbuild
#
# Return all tokens after TOKEN via the RETARR_ARGSAFTER
#
#    myargs=(one two -- three "four and" five)
# 	args:after -- "${myargs[@]}"
#
# 	for a in "${RETARR_ARGSAFTER}"; do
# 		echo "$a"
# 	done
#
# The above prints
#
# 	three
# 	four and
# 	five
#
###/doc

function args:after {
    local token="$1"; shift || :
    
    local current_token="$1"; shift || :
    while [[ "$#" -gt 0 ]] && [[ "$current_token" != "$token" ]]; do
        current_token="$1"; shift || :
    done

    RETARR_ARGSAFTER=("$@")
}

set -euo pipefail

### JKS manipulator Usage:jksm
#Manipulate a Java Key Store or PKCS12 store using 'keytool' (which has too many options to remember for infrequent use ...)
#
#There are typically 3 options to the jks subcommand:
#
#-k KEYSTORE : the keystore to operate on
#-a ALIAS : the alias to use for the operation, where appropriate
#-f TARGETFILE : the file that will be read from or written to, changing depending on the command
#
#
#certmaker jks generate -k KEYSTORE -a ALIAS
#
#    Create a new key store, with a key alias
#
#
#certmaker jks csr -k KEYSTORE -a ALIAS -f CSRFILE
#
#    Derive a CSR from the KEYSTORE from the ALIAS entry
#
#
#certmaker jks add-ca -k KEYSTORE -a ALIAS -f CACERT
#
#    Add a CA certificate file CACERT to the KEYSTORE under ALIAS
#
#
#certmaker jks add-cert -k KEYSTORE -a ALIAS -f CERT
#
#    Add a certificate file CERT to the KEYSTORE under ALIAS
#
#
#certmaker jks add-key -k KEYSTORE -a ALIAS -f KEYFILE
#
#    Add a key file KEYFILE to the KEYSTORE under ALIAS
#
#    The key file must be either in PEM or PKCS12 format
#    If in PEM format, a similarly named CER file must accompany it
#
#    e.g. "import/application.key" needs a corresponding "import/application.cer" file
#
#
#certmaker jks delete -k KEYSTORE -a ALIAS
#
#    Delete an alias ALIAS from the KEYSTORE
#
#
#certmaker jks view -k KEYSTORE [-a ALIAS]
#
#    View the contents of the keystore, or optionally the contents under the keystore alias
#
#certmaker jks rename -k KEYSTORE -a OLDALIAS:NEWALIAS
#
#    Rename an old alias to a new one by cloning the old to new, and deleting the old one.
###/doc

jks:dispatch() {
    action="$1"; shift

    case "$action" in
        generate)
            jks:gen ;;

        csr)
            jks:csr ;;

        add-ca)
            jks:add:cacert ;;

        add-cert)
            jks:add:cert ;;

        add-key)
            jks:add:key ;;

        delete)
            jks:delete ;;

        view)
            jks:view ;;
        rename)
            jks:rename ;;

        *)
            out:fail "Unknown action '$action'" ;;
    esac
}

jks:args() {
    local flag

    for flag in "$@"
    do
        case "$flag" in
        -k)
            keystore="$(args:get -k "${SCRIPT_ARGS[@]}")"
            ;;
        -f)
            targetfile="$(args:get -f "${SCRIPT_ARGS[@]}")"
            ;;
        -a)
            ksalias="$(args:get -a "${SCRIPT_ARGS[@]}")"
            ;;

        esac
    done
}

jks:convert_key() {
    local certfile="${targetfile%.*}.cer"
    [[ -f "$certfile" ]] || out:fail "You must provide the certificate file as $certfile"
    out:info "Combining $targetfile and $certfile"

    # FIXME this generates error "unable to write 'random state'" even though output/result looks fine...
    openssl pkcs12 -export -inkey "$targetfile" -in "$certfile"
}

jks:gen() {
    jks:args -k || out:fail "Keystore is required"
    jks:args -f || :

    if [[ -z "${targetfile:-}" ]]; then
        jks:args -a || out:fail "Alias is required"
        keytool -genkey -alias "$ksalias" -keyalg RSA -keystore "$keystore" -deststoretype pkcs12 # FIXME This is still generateing JKS store??
    else
        jks:convert_key > "$keystore" # provided through $targetfile
    fi

}

jks:csr() {
    jks:args -k -a -f || out:fail "Keystore, Alias and Output CSR file are required"
    keytool -certreq -keyalg RSA -alias "$ksalias" -keystore "$keystore" -file "$targetfile"
}

jks:add:cacert() {
    jks:args -k -a -f || out:fail "Keystore, Alias and CA cert are required"
    keytool -import -alias "$ksalias" -keystore "$keystore" -trustcacerts -file "$targetfile"
}

jks:add:cert() {
    jks:args -k -a -f || out:fail "Keystore, Alias and Cert are required"
    keytool -import -alias "$ksalias" -keystore "$keystore" -file "$targetfile"
}

jks:ensure_pkcs12() {
    if [[ "$targetfile" =~ \.*\.p12 ]]; then
        cat "$targetfile"

    elif grep -qP "PRIVATE KEY" "$targetfile"; then
        out:warn "You provided PEM files - we will create a temporary store in which to put the key and certificate"
        jks:convert_key

        out:warn "You will be asked for the destination store password (your keystore) and the source store password (the intermediate store) to complete the import."
    else
        out:fail "PEM or PKCS12 file required!"
    fi
}

jks:cleanup() {
    if [[ -f "${p12datafile:-}" ]]; then
        rm "$p12datafile"
    fi
}

jks:add:key() {
    # Annoyingly, keytool needs a PKCS12 store for importing - it can't simply add a key
    jks:args -k -f || out:fail "Keystore and Key file ({.key + .cer} or .p12) are required"

    trap jks:cleanup EXIT

    p12datafile="$(mktemp XXXX.p12)"
    jks:ensure_pkcs12 > "$p12datafile" # Should fail on its own here if bad file

    keytool -importkeystore -srckeystore "$p12datafile" -destkeystore "$keystore" -srcstoretype pkcs12

    jks:cleanup
}

jks:delete() {
    jks:args -k -a || out:fail "Keystore and Alias are required"
    keytool -delete -alias "$ksalias" -keystore "$keystore"
}

jks:view() {
    jks:args -k || out:fail "Keystore is required"
    jks:args -a || :
    if [[ -n "${ksalias:-}" ]]; then
        keytool -list -alias "$ksalias" -keystore "$keystore"

    else
        keytool -list -keystore "$keystore"
    fi
}

jks:rename() {
    jks:args -k -a || out:fail "Keystore required ; Alias required as \`oldalias:newalias\`"

    local oldalias="${ksalias%:*}"
    local newalias="${ksalias#*:}"

    out:warn "We'll clone the old alias to a new name, then delete the old alias."
    ( set -ex
        keytool -keyclone -alias "$oldalias" -dest "$newalias" -keystore "$keystore"
        keytool -delete -alias "$oldalias" -keystore "$keystore"
    )
}

jksm:main() {
    if [[ -z "$*" ]] || [[ "$*" =~ --help ]]; then
        autohelp:print jksm
        exit
    fi

    bincheck:has keytool || out:fail "'keytool' is not installed - try installing openjdk-8-jre-headless"
    bincheck:has openssl || out:warn "'openssl' is not installed - key conversions will fail"

    SCRIPT_ARGS=("$@")
    jks:dispatch "$@"
}

cm:main() {
    # Do not autohelp:check here, as it would override sub-topic help
    [[ -n "$*" ]] || {
        autohelp:print
        exit 0
    }
    action="$1"; shift || :

    # Config-less modules
    case "$action" in
        view|fetch)
            cert-getter:main "$action" "$@"
            return
            ;;
        jks)
            jksm:main "$@"
            return
            ;;
        help|--help)
            cm:guide
            return 0
            ;;
    esac

    cm:config:load_config
    cm:checkuser

    case "$action" in
        template)
            cm:template "$@"
            ;;
	csr)
		cm:csr "$@"
		;;
        new)
            cm:new "$@"
            ;;
        edit)
            cm:edit "$@"
            ;;
        sign)
            cm:sign "$@"
            ;;
        renew)
            cm:renew "$@"
            ;;
        paths)
            cm:paths "$@"
            ;;
        quick)
            cm:quick "$@"
            ;;
        *)
            autohelp:print
            out:fail "Unknown action $action"
            ;;
    esac
}

cm:checkuser() {
    local iam=$(whoami)

    if [[ "$cmuser" = root ]] && [[ "$iam" != 'root' ]]; then
        out:fail "CertMaker is installed for the root user. Only the root user can use it now."
    fi

    [[ "$cmuser" = "$iam" ]] || {
        out:warn "Loaded Certmaker config was installed for '$cmuser'."
        askuser:confirm "Continue?"
    }
}

cm:helpcheck() {

    local section="$1"; shift

    if [[ "$*" =~ --help ]] || [[ -z "$*" ]]; then
        autohelp:print "$section"
        exit 0
    fi

    return 0
}

cm:main "$@"
