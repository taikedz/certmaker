#!/usr/bin/env bash

# This software is Free Software
# (C) Tai Kedzierski 2017-2018
#
# It is provided to you under the terms of the GNU General Public License v3
# https://www.gnu.org/licenses/gpl-3.0.html

### certmaker Usage:help
#
# Tool to generate a CA, generate keys and CSRs, and sign CSRs
#
# From https://github.com/taikedz/CertMaker
#
# Run
#
#   certmaker help
#
# for a quick-start manual
# 
# ### Listing profiles
#
# List host profiles
#
#   certmaker paths
#
# List key and certificate for a host profile
#
#   certmaker paths HOST
#
#
# ### Creating and signing profiles
#
# Create a new host profile, edit it:
#
#     certmaker new host HOST
#     certmaker edit HOST
#
# Regenerate host profile assets
#
#   certmaker renew key { HOST | CONFIG [KEYFILE] }
#   certmaker renew csr { HOST | KEYFILE CONFIG [CSRFILE] }
#
# Sign a host profile or CSR file:
#
#     certmaker sign { HOST | CSRFILE [CERTFILE] }
#
#
# ### Generate new CA or templates
#
# Generate a new template configuration file
#
#   certmaker template { ca | host } [CONFFILE]
#
# Create a new CA:
#
#     certmaker new ca CONFFILE
#
#
###/doc

##bash-libs: safe.sh @ 75ff4139-modified (1.1)

### Safe mode Usage:bbuild
#
# Set safe mode options
#
# * Script bails on error
# * Accessing a variable that is not set is an error
# * If a file glob does not expand, cause an error condition
# * If a component of a pipe fails, the entire pipe is a failure
#
###/doc

set -eufo pipefail
##bash-libs: autohelp.sh @ 75ff4139-modified (1.1)

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#    ### <title> Usage:help
#    #
#    # <some content>
#    #
#    # end with "###/doc" on its own line (whitespaces before
#    # and after are OK)
#    #
#    ###/doc
#
# You can set a different help section by specifying a subsection
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
#
###/doc

HELPCHAR='#'

function autohelp:print {
    local SECTION_STRING="${1:-}"; shift || :
    local TARGETFILE="${1:-}"; shift || :
    [[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
    [[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
                echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
    echo ""
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
function autohelp:paged {
    : ${PAGER=less}
    autohelp:print "$@" | $PAGER
}

### autohelp:check Usage:bbuild
#
# Automatically print help and exit if "--help" is detected in arguments
#
# Example use:
#
#    #!/bin/bash
#
#    ### Some help Usage:help
#    #
#    # Some help text
#    #
#    ###/doc
#
#    #%include autohelp.sh
#
#    main() {
#        autohelp:check "$@"
#
#        # now add your code
#    }
#
#    main "$@"
#
###/doc
autohelp:check() {
    if [[ "$*" =~ --help ]]; then
        cols="$(tput cols)"
        autohelp:print | fold -w "$cols" -s || autohelp:print
        exit 0
    fi
}
##bash-libs: out.sh @ 75ff4139-modified (1.1)

##bash-libs: colours.sh @ 75ff4139-modified (1.1)

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo -e "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour")
#
# Requires processing of escape characters.
#
# Colours available:
#
# CRED, CBRED, HLRED -- red, bold red, highlight red
# CGRN, CBGRN, HLGRN -- green, bold green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bold yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bold blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bold purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bold teal, highlight teal
#
# CDEF -- switches to the terminal default
# CUNL -- add underline
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
# If the session is detected as being in a pipe, colours will be turned off.
#   You can override this by calling `colours:check --color=always` at the start of your script
#
###/doc

##bash-libs: tty.sh @ 75ff4139-modified (1.1)

tty:is_ssh() {
    [[ -n "$SSH_TTY" ]] || [[ -n "$SSH_CLIENT" ]] || [[ "$SSH_CONNECTION" ]]
}

tty:is_pipe() {
    [[ ! -t 1 ]]
}

### colours:check ARGS Usage:bbuild
#
# Check the args to see if there's a `--color=always` or `--color=never`
#   and reload the colours appropriately
#
###/doc
colours:check() {
    if [[ "$*" =~ --color=always ]]; then
        COLOURS_ON=true
    elif [[ "$*" =~ --color=never ]]; then
        COLOURS_ON=false
    fi

    colours:define
    return 0
}

colours:auto() {
    if tty:is_pipe ; then
        COLOURS_ON=false
    else
        COLOURS_ON=true
    fi

    colours:define
    return 0
}

colours:define() {
    if [[ "$COLOURS_ON" = false ]]; then

        export CRED=''
        export CGRN=''
        export CYEL=''
        export CBLU=''
        export CPUR=''
        export CTEA=''

        export CBRED=''
        export CBGRN=''
        export CBYEL=''
        export CBBLU=''
        export CBPUR=''
        export CBTEA=''

        export HLRED=''
        export HLGRN=''
        export HLYEL=''
        export HLBLU=''
        export HLPUR=''
        export HLTEA=''

        export CDEF=''

    else

        export CRED=$(echo -e "\033[0;31m")
        export CGRN=$(echo -e "\033[0;32m")
        export CYEL=$(echo -e "\033[0;33m")
        export CBLU=$(echo -e "\033[0;34m")
        export CPUR=$(echo -e "\033[0;35m")
        export CTEA=$(echo -e "\033[0;36m")

        export CBRED=$(echo -e "\033[1;31m")
        export CBGRN=$(echo -e "\033[1;32m")
        export CBYEL=$(echo -e "\033[1;33m")
        export CBBLU=$(echo -e "\033[1;34m")
        export CBPUR=$(echo -e "\033[1;35m")
        export CBTEA=$(echo -e "\033[1;36m")

        export HLRED=$(echo -e "\033[41m")
        export HLGRN=$(echo -e "\033[42m")
        export HLYEL=$(echo -e "\033[43m")
        export HLBLU=$(echo -e "\033[44m")
        export HLPUR=$(echo -e "\033[45m")
        export HLTEA=$(echo -e "\033[46m")

        export CDEF=$(echo -e "\033[0m")

    fi
}

colours:auto

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'true' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'true' to enable command echoing
#
###/doc

: ${MODE_DEBUG=false}
: ${MODE_DEBUG_VERBOSE=false}

# Internal
function out:buffer_initialize {
    OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "true"
###/doc
function out:debug {
    if [[ "$MODE_DEBUG" = true ]]; then
        echo "${CBBLU}DEBUG: $CBLU$*$CDEF" 1>&2
    fi
}

### out:debug:fork [MARKER] Usage:bbuild
#
# Pipe the data coming through stdin to stdout
#
# If debug mode is on, *also* write the same data to stderr, each line preceded by MARKER
#
# Insert this debug fork into pipes to see their output
#
###/doc
function out:debug:fork {
    if [[ "$MODE_DEBUG" = true ]]; then
        local MARKER="${1:-DEBUG: }"; shift || :

        cat - | sed -r "s/^/$MARKER/" | tee -a /dev/stderr
    else
        cat -
    fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
    echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
    echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
    OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
    [[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

    [[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

    for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
        "$@" "$buffer_line"
    done

    out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
    local ERCODE=127
    local numpat='^[0-9]+$'

    if [[ "$1" =~ $numpat ]]; then
        ERCODE="$1"; shift || :
    fi

    echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
    exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
    echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

### out:dump Usage:bbuild
#
# Dump stdin contents to console stderr. Requires debug mode.
#
# Example
#
# 	action_command 2>&1 | out:dump
#
###/doc

function out:dump {
    echo -n "${CBPUR}$*" 1>&2
    echo -n "$CPUR" 1>&2
    cat - 1>&2
    echo -n "$CDEF" 1>&2
}

### out:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires MODE_DEBUG set to true
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Press return to continue execution.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
###/doc

function out:break {
    [[ "$MODE_DEBUG" = true ]] || return 0

    echo -en "${CRED}BREAKPOINT: $* >$CDEF " >&2
    read
    if [[ "$REPLY" =~ quit|exit|stop ]]; then
        out:fail "ABORT"
    fi
}

if [[ "$MODE_DEBUG_VERBOSE" = true ]]; then
    set -x
fi
##bash-libs: searchpaths.sh @ 75ff4139-modified (1.1)


# FIXME - set function signature in head of help
### searchpaths:file_from PATHDEF FILE Usage:bbuild
#
# Locate a file along a search path.
#
# EXAMPLE
#
# The following will look for each of the files
#  in order of preference of a local lib directory, a profile-wide one, then a system-
#  wide one.
#
#    MYPATH="./lib:$HOME/.local/lib:/usr/local/lib"
# 	searchpaths:file_from "$MYPATH" file
#
# Echoes the path of the first file found.
#
# Returns 1 on failure to find any file.
#
###/doc

function searchpaths:file_from {
    local PATHS="$1"; shift || :
    local FILE="$1"; shift || :

    out:debug "Looking for file [$FILE] amongst [$PATHS]"

    for path in $(echo "$PATHS"|tr ':' ' '); do
        out:debug "Try path: $path"
        local fpath="$path/$FILE"
        if [[ -f "$fpath" ]]; then
            echo "$fpath"
            return 0
        else
            out:debug "No $fpath"
        fi
    done
    return 1
}
##bash-libs: vars.sh @ 75ff4139-modified (1.1)

### Vars library Usage:bbuild
#
# Functions for checking variables
#
###/doc

### vars:require VARNAME ... Usage:bbuild
#
# Check a list of environment variables such that none are non-empty.
#
# If variables are empty/not set, the name is echoed.
#
# Returns the number of missing variables.
#
#    myvarA=one
#    myvarB=
#    myvarC=three
#
#    missing="$(vars:require myvarA myvarB myvarC)"
#
#    if [[ -n "$missing" ]]; then
#        out:fail "Variables were not set : [$missing]"
#    fi
#
###/doc

vars:require() {
    local missing=(:)

    for varname in "$@"; do
        echo "[[ -n "\$$varname" ]]" | bash || {
            missing[${#missing[@]}]="$varname"
        }
    done

    missing=("${missing[@]:1}")

    echo "${missing[*]}"
    return "${#missing[@]}"
}

CERTMAKER_confpaths=".:$HOME/.config/certmaker:/etc/certmaker"

cm:config:load_config() {
	local conffile="$(searchpaths:file_from "$CERTMAKER_confpaths" certmaker.config)"

	if [[ -z "$conffile" ]]; then
		out:fail "No config file found."
	fi

	. "$conffile"
}

cm:config:get_temp() {
    echo "$cnftemplates/$1.cnf"
}

cm:template() {
    local fromfile
    local target="$1"; shift
    local outfile="${1:-}"; shift || :

    case "$target" in
    ca|host)
        fromfile="$(cm:config:get_temp "$target")"
        [[ -n "${outfile:-}" ]] || outfile="./$(basename "$fromfile")"

        sed "
        s|%CASTOREDIR%|$castore|
        " "$fromfile" > "$outfile"
        echo "New template in $outfile"
        ;;
    *)
        out:fail "No template for $target"
        ;;
    esac
}

::() {
    [[ -n "$*" ]] || out:fail "No command specified"

	echo  "${CBTEA}$*${CDEF}"

	if [[ "${DRYRUN:-}" != true ]]; then
		"$@"
	fi
}

### New Certificate Authority Usage:new-ca
#
# Create and manage a certificate authority
#
# 	certmaker new ca SSLCONF
#
# Create your SSL config file, and pass it in as SSLCONF
#
# Ensure you have a `keysize` and `hashalgorithm` entry in your certmaker config
#
# If in doubt, use
#
# 	keysize=4096
# 	hashalgorithm=sha256
#
###/doc

cm:ca:new-ca() {
	cm:helpcheck new-ca "$@"
	local sslconf
	sslconf="${1:-}" ; shift || :

    [[ -n "${sslconf:-}" ]] || out:fail "Provide the SSL config file"

	[[ ! -e "$castore" ]] || out:fail "'$castore' must not exist. Archive the existing directory, and try again."

	mkdir -p "$castore"
	chmod 700 "$castore"

	cp "$sslconf" "$castore/authority.cnf"

	:: openssl req -x509 -config "$castore/authority.cnf" -out "$castore/authority.cer" -outform PEM -keyout "$castore/authority.key" -newkey rsa:"$keysize" -"$hashalgorithm"

	out:info "You can store the certificate password in [$castore/pass.txt] for automatic signing"
}
##bash-libs: askuser.sh @ 75ff4139-modified (1.1)

### askuser Usage:bbuild
# Present the user with questions on stderr
###/doc


yespat='^(yes|YES|y|Y)$'
numpat='^[0-9]+$'
rangepat='[0-9]+,[0-9]+'
listpat='^[0-9 ]+$'
blankpat='^ *$'

### askuser:confirm Usage:bbuild
# Ask the user to confirm a closed question. Defaults to no
#
# returns 0 on successfully match 'y' or 'yes'
# returns 1 otherwise
###/doc
function askuser:confirm {
    read -p "$* [y/N] > " 1>&2
    if [[ "$REPLY" =~ $yespat ]]; then
        return 0
    else
        return 1
    fi
}

### askuser:ask Usage:bbuild
# Ask the user to provide some text
#
# Echoes out the entered text
###/doc
function askuser:ask {
    read -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:password Usage:bbuild
# Ask the user to enter a password (does not echo what is typed)
#
# Echoes out the entered text
###/doc
function askuser:password {
    read -s -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:choose_multi Usage:bbuild
# Allows the user to choose from multiple choices
#
# askuser:chose_multi MESG CHOICESTRING
#
#
# MESG is a single string token that will be displayed as prompt
#
# CHOICESTRING is a comma-separated, or newline separated, or "\\n"-separated token string
#
# Equivalent strings include:
#
# * `"a\\nb\\nc"` - quoted and explicit newline escapes
# * `"a,b,c"` - quoted and separated with commas
# * `a , b , c` - not quoted, separated by commas
# * `a`, `b` and `c` on their own lines
#
# User input:
#
# User can choose by selecting
#
# * a single item by number
# * a range of numbers (4,7 for range 4 to 7)
# * or a string that matches the pattern
#
# All option lines that match will be returned, one per line
#
# If the user selects nothing, then function returns 1 and an empty stdout
###/doc
function askuser:choose_multi {
    local mesg=$1; shift || :
    local choices=$(echo "$*"|sed -r 's/ *, */\n/g')
    out:debug "CHOICES: $choices"

    out:info "$mesg:" 
    local choicelist="$(echo -e "$choices"|egrep '^' -n| sed 's/:/: /')"
    echo "$choicelist" 1>&2
    
    local sel=$(askuser:ask "Choice")
    if [[ "$sel" =~ $blankpat ]]; then
        return 1

    elif [[ "$sel" =~ $numpat ]] || [[ "$sel" =~ $rangepat ]]; then
        out:debug "Number choice [$sel]"
        echo -e "$choices" | sed -n "$sel p"
    
    elif [[ "$sel" =~ $listpat ]]; then
        echo "$choicelist" | egrep "^${sel// /|}:" | sed -r 's/^[0-9]+: //'

    else
        out:debug "Pattern choice [$sel]"
        echo -e "$choices"  |egrep "$(echo "$sel"|tr " " '|')"
    fi
    return 0
}

### askuser:choose Usage:bbuild
# Ask the user to choose an item
#
# Like askuser:choose_multi, but will loop if the user selects more than one item
#
# If the user provides no entry, returns 1
#
# If the user chooses one item, that item is echoed to stdout
###/doc
function askuser:choose {
    local mesg=$1; shift || :
    while true; do
        local thechoice="$(askuser:choose_multi "$mesg" "$*")"
        local lines=$(echo -n "$thechoice" | grep '$' -c)
        if [[ $lines = 1 ]]; then
            echo "$thechoice"
            return 0
        elif [[ $lines = 0 ]]; then
            return 1
        else
            out:warn "Too many results"
        fi
    done
}

### CSR Signing Usage:sign
#
# Sign a known host or csr
#
# 	certmaker sign host HOSTNAME
#
# 	certmaker sign csr CSRFILE
#
###/doc

cm:sign() {
	cm:helpcheck sign "$@"
	
	local target="${1:-}"; shift || out:fail "Specify target to sign"

    if [[ -f "$target" ]]; then
		cm:sign:csr "$target" "$@"
    else
		cm:sign:host "$target" "$@"
    fi
}

cm:sign:csr() {
	local csrfile certfile opssl_opts passfile passin
	csrfile="$1"; shift
	certfile="${csrfile%.*}.cer"

	cm:sign:overwrite_check "$certfile"

	files:ensure_file "$castore/index.txt"
	files:ensure_file "$castore/serial.txt" '01'

    passfile="$castore/pass.txt"

    opssl_opts=( -config "$castore/authority.cnf" -policy signing_policy -extensions signing_req -out "$certfile" -infiles "$csrfile")

	# Switch to batch mode when password file exists
    if [[ -f "$passfile" ]]; then
        :: openssl ca -batch -passin "file:$passfile" "${opssl_opts[@]}"
    else
        :: openssl ca "${opssl_opts[@]}"
    fi
}

cm:sign:host() {
    local host_name hostd
    host_name="$1"; shift
    hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "No such host profile '$host_name'"

    cm:sign:csr "$hostd/$host_name.csr" "$hostd/$host_name.cer"
}

cm:sign:overwrite_check() {
	local certfile="$1"; shift
	
	[[ -f "$certfile" ]] || return 0

	askuser:confirm "${CYEL}Overwrite '$certfile'?$CDEF" || out:fail "Abort."

	rm "$certfile" || out:fail "Could not remove '$certfile'"
}


files:ensure_file() {
	local target="$1"; shift
	local tdir="$(dirname "$target")"

	[[ -d "$tdir" ]] || mkdir -p "$tdir"

	[[ -f "$target" ]] || echo -n "$*" > "$target"
}
### New registered host Usage:new-host
#
# Create a new stored host for certfiying
#
# Generates a key + CSR pair stored against the name
#
# 	certmaker new host HOST
#
###/doc

cm:host:new-host() {
	cm:helpcheck new-host "$@"

	if [[ -z "$*" ]]; then
		out:fail "You need to specify a name for the host configuration. Try adding '--help'"
	fi

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ "$myhost" =~ ^[a-zA-Z0-9_.-]+$ ]] || out:fail "Host name can only contain letters, numbers, underscore, period and dash."

	[[ ! -d "$myhostd" ]] || out:fail "Host '$myhost' already exists."

	mkdir -p "$myhostd"

	cm:template host "$myhostd/$myhost.cnf"
}

### Edit host config Usage:edit
#
#	certmaker edit HOST
#
# Edit the SSL config for the registered host
#
###/doc

cm:host:edit-host() {
	cm:helpcheck edit "$@"

	if [[ -z "$*" ]]; then
		out:fail "You need to specify a name for the host configuration. Try adding '--help'"
	fi

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ -d "$myhostd" ]] || out:fail "Host '$myhost' does not exist."

	EDITOR="${EDITOR:-nano}"

	exec "$EDITOR" "$myhostd/$myhost.cnf"
}
### New entity Usage:new
#
# Create a new Certificate Authority, or Host
#
#   certmaker new host HOSTNAME
#
#   certmaker new ca CACONF
#
# You can generate a CACONF file with
#
#   certmaker template ca [CACONF]
#
###/doc

cm:new() {
    cm:helpcheck new "$@"

	local target="$1"; shift

	case "$target" in
	ca)
		cm:ca:new-ca "$@"
		;;
	host)
		cm:host:new-host "$@"
		;;
	*)
		out:fail "Unknown target for new: '$target'"
		;;
	esac
}
### CSR Regenration Usage:renew
#
# (Re-)generate key for the host or config.
#
#	certmaker renew key CONFIG [KEYFILE]
#	certmaker renew key HOST
#
# (Re-)generate CSR for the host or key+config file pair
#
#	certmaker renew csr KEYFILE CONFIG [CSRFILE]
#	certmaker renew csr HOST
#
###/doc

cm:renew() {
    cm:helpcheck renew "$@"

    local rtype="${1:-}" ; shift || out:fail "Specify renewal type"
    local filehost="${1:-}" ; shift || out:fail "Specify target file or host"

    case "$rtype" in
    csr|key)
        if [[ -f "$filehost" ]]; then
            cm:renew:${rtype}-file "$filehost" "$@"
        else
            cm:renew:${rtype}-host "$filehost" "$@"
        fi
        ;;
    *)
        out:fail "Unknown renewal type '$rtype'"
        ;;
    esac
}

cm:renew:key-file() {
    local config keyfile

    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"
    keyfile="${1:-}"; shift || {
        keyfile="${config%.*}.key"
    }

    :: openssl genrsa -out "$keyfile" "$keysize" -config "$config"
}

cm:renew:key-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:key-file "$hostd/${host_name}.cnf" "$hostd/${host_name}.key"
}

cm:renew:csr-file() {
    local keyfile csrfile config
    keyfile="${1:-}"; shift || out:fail "Specify an input key file"
    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"

    csrfile="${1:-}"; shift || {
        csrfile="${keyfile%.*}.csr"
    }

    :: openssl req -new -key "$keyfile" -out "$csrfile" -config "$config"
}

cm:renew:csr-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:csr-file "$hostd/${host_name}.key" "$hostd/${host_name}.cnf" "$hostd/${host_name}.csr"
}
cm:paths() {
    local host_name hostd

    host_name="${1:-}"; shift || {
        cm:paths:list
        return
    }

    hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "Unknown host profile '$host_name'"

    ls "$hostd/$host_name."{key,cer}
}

cm:paths:list() {
    find "$hoststore" -name '*.cnf' -exec dirname {} \; | sed "s|$hoststore/||"
}

cm:guide() {
cat <<'EOHELP'
# CertMaker

A tool to create an OpenSSL certificate authority, and generate certificates, for use on internal networks.

This tool is intended as a security admin tool for internal websites, and assumes by default that the entity creating the CA and managing the certs can deploy them, in which case it should NOT be used for public websites.

It can optionally be used by site owners to generate their own keys and CSRs, to send along, and for CAs to sign ad-hoc CSRs. You can use this tool for generating your CSRs for sending to trusted and/or commercial CAs.

## Install certmaker

	sudo ./install.sh

Configuration is palced in `/etc/certmaker/certmaker.config`

If you do not install as root, it is placed in `~/.config/certmaker/certmaker.config`

## Quick start

### New CA

Get new CA config file. Edit the CNF file, specifically ensure you update the organisation country and details

	certmaker template ca authority.cnf

Now initialize a new store with that config

	certmaker new ca authority.cnf

    # You can delete the local cnf now
    # rm authority.cnf

### Centrally managed hosts

If you want the CA to manage both keys and certificates for host machines, use these steps. In this scenario, the CA is responsible for creating both the keys and the certificates that will be placed on host machines.


Create a new host profile ("host")

	certmaker new host myhost

Change host config, then generate key and CSR files

	certmaker edit myhost
	certmaker renew key myhost
	certmaker renew csr myhost

Sign the host's CSR

	certmaker sign host myhost

List the key and certificate paths, copy the files to your target host

	certmaker paths myhost

## Extra steps

To renew a certificate, just sign the existing host definition.

	certmaker sign host myhost

You will need to copy the new certificate to the desired host machine to replace the old certificate.

## Generic CSR and CA activities

### Target host

If you simply want to create a CSR for your machine, to send to a remote CA for signing:

On the target host to receive a certificate, create a CSR

	certmaker template host myhost.cnf

	# Edit the ./myhost.cnf file that is created

    # If you don't already have a key
    #certmaker renew key ./myhost.cnf
	
	certmaker renew csr ./key-file.key ./myhost.cnf

This will create a CSR file `myhost.csr` to send to the CA

### Certificate Authority

On receipt of a CSR, simply use the `sign csr` command:

	certmaker sign csr CSRFILE [CERTFILE]

This will generate a certificate file as specified, or with the same base name as the CSR, to send back to the requestor.
EOHELP
}

cm:main() {
    # Do not autohelp:check here, as it would override sub-topic help
    [[ -n "$*" ]] || {
        autohelp:print
        exit 0
    }
    action="$1"; shift || :

    cm:config:load_config

    case "$action" in
        template)
            cm:template "$@"
            ;;
        new)
            cm:new "$@"
            ;;
        edit)
            cm:host:edit-host "$@"
            ;;
        sign)
            cm:sign "$@"
            ;;
        renew)
            cm:renew "$@"
            ;;
        help)
            cm:guide
            exit 0
            ;;
        paths)
            cm:paths "$@"
            ;;
        *)
            autohelp:print
            out:fail "Unknown action $action"
            ;;
    esac
}

cm:helpcheck() {
    local section="$1"; shift

    [[ "$*" =~ --help ]] || return 0

    autohelp:print "$section"

    exit 0
}

cm:main "$@"
