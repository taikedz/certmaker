#!/usr/bin/env bash

# This software is Free Software
# (C) Tai Kedzierski 2017-2018
#
# It is provided to you under the terms of the GNU General Public License v3
# https://www.gnu.org/licenses/gpl-3.0.html


### certmaker Usage:help
#
# Tool to generate a CA, generate keys and CSRs, and sign CSRs
#
# From https://github.com/taikedz/CertMaker
#
# Further below are /all/ the available commands, but you probably only want one of the following:
#
#   certmaker new ca
#   certmaker quick --edit
#   certmaker quick HOST
#   certmaker paths [HOST]
#   certmaker view CERTFILE
#
# Run
#
#   certmaker help
#
# for a quick-start tutorial.
#
#
#
#
#
# 
# ### Listing profiles
#
# List host profiles
#
#   certmaker paths
#
# List key and certificate for a host profile
#
#   certmaker paths HOST
#
#
# ### Creating and signing profiles
#
# Create a new host profile, edit it:
#
#     certmaker new host HOST
#     certmaker edit HOST
#
# Regenerate host profile assets
#
#   certmaker renew key { HOST | CONFIG [KEYFILE] }
#   certmaker renew csr { HOST | KEYFILE CONFIG [CSRFILE] }
#
# Sign a host profile or CSR file:
#
#     certmaker sign { HOST | CSRFILE [CERTFILE] }
#
#
# ### Generate new CA or templates
#
# Generate a new template configuration file
#
#   certmaker template { ca | host } [DESTFILE]
#
# Create a new CA:
#
#     certmaker new ca
#
# ### Certificate viewing and fetching
#
# Fetch a site's certificate, and view a certificate file
#
#   certmaker fetch { DOMAIN | URL }
#
#   certmake view CERTFILE
#
#
###/doc
cm:guide() {
cat <<'EOHELP' | less
CertMaker
===========

A tool to create an OpenSSL certificate authority, and generate certificates, for use on internal networks.

The tool is written with two uses cases in mind:

* As an *internal* CA tool that will act as CA and manage cert/key pairs centrally, distributing them to target servers
    * the `quick` mode is an implementation of this workflow
* As a *CSR client* tool for generating CSRs to be sent to CAs
* As a plain internal CA that can sign individual CSRs

If you are deploying a public-facing web site, please consider using [Let's Encrypt](https://letsencrypt.org)



Install certmaker
-----------------

    sudo ./install.sh

Configuration is palced in `/etc/certmaker/certmaker.config`

If you do not install as root, it is placed in `~/.config/certmaker/certmaker.config`

Ensure your `EDITOR` environment variable is set to your preferred text editor; if it is not set, CertMaker will try to use Emacs, nano, vim or vi.



New CA
---------

Sets up a new CA config, and opens an editor; specifically ensure you update the organisation country and details. You can also edit the `default_days` property to specify the number of days a newly signed cert is valid for. You will be prompted for a password for the key.

    certmaker new ca

Set up a generic hosts config which will be used as a template for managed hosts

    certmaker quick --edit

It is possible to save a password file in plaintext in `$CERTMAKERCONFIG/ca/pass.txt` to allow running in batch mode; treat this with caution.


Centrally managed hosts
-----------------------

If you want the CA to manage both keys and certificates for host machines, use these steps. In this scenario, the CA is responsible for creating both the keys and the certificates that will be placed on host machines.

Create a new host profile - you will be prompted to edit it, and will then be given paths to a key and cert file as a result.

    certmaker quick myhost

Re-run the command any time you want to renew the certificate. You will need to copy the new certificate to the desired host machine to replace the old certificate.



Generic CSR and CA activities
-----------------------------


###    Target host

If you simply want to create a CSR for your machine, to send to a remote CA for signing:

Create a configuration for the CSR, and edit it

    certmaker template host myhost.cnf
    nano myhost.cnf

If you don't already have a key, create one form the config

    certmaker renew key ./myhost.cnf

Finally, create the CSR

    certmaker renew csr ./key-file.key ./myhost.cnf


This will create a CSR file `myhost.csr` to send to the CA



###    Certificate Authority

On receipt of a CSR, simply use the `sign csr` command:

    certmaker sign csr CSRFILE [CERTFILE]

This will generate a certificate file as specified, or with the same base name as the CSR, to send back to the requestor.




View a certificate
------------------

You can inspect the contents of a certificate PEM file (typically a block of base-64 data bounded with `BEGIN` and `END` statements) using

    certmaker view CERTFILE

Certificates generated by CertMaker are always PEM files.


EOHELP
}
### Certificate Getter Usage:cert-getter
#
# Certificate fetch and view agent.
#
#     certmaker fetch [SCHEME://]DOMAIN[:PORT]
#     certmaker view CERTFILE
#
# Fetch the certificate for a HTTPS domain to a file, or view the contents of a certificate file
#
# DOMAIN is the domain name to check, by default on port 443
#
# You can specify an alternative port, for example
#
#     certmaker fetch mydomain.net:8443
#
###/doc

##bash-libs: out.sh @ 75ff4139-modified (1.1)

##bash-libs: colours.sh @ 75ff4139-modified (1.1)

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo -e "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour")
#
# Requires processing of escape characters.
#
# Colours available:
#
# CRED, CBRED, HLRED -- red, bold red, highlight red
# CGRN, CBGRN, HLGRN -- green, bold green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bold yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bold blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bold purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bold teal, highlight teal
#
# CDEF -- switches to the terminal default
# CUNL -- add underline
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
# If the session is detected as being in a pipe, colours will be turned off.
#   You can override this by calling `colours:check --color=always` at the start of your script
#
###/doc

##bash-libs: tty.sh @ 75ff4139-modified (1.1)

tty:is_ssh() {
    [[ -n "$SSH_TTY" ]] || [[ -n "$SSH_CLIENT" ]] || [[ "$SSH_CONNECTION" ]]
}

tty:is_pipe() {
    [[ ! -t 1 ]]
}

### colours:check ARGS Usage:bbuild
#
# Check the args to see if there's a `--color=always` or `--color=never`
#   and reload the colours appropriately
#
###/doc
colours:check() {
    if [[ "$*" =~ --color=always ]]; then
        COLOURS_ON=true
    elif [[ "$*" =~ --color=never ]]; then
        COLOURS_ON=false
    fi

    colours:define
    return 0
}

colours:auto() {
    if tty:is_pipe ; then
        COLOURS_ON=false
    else
        COLOURS_ON=true
    fi

    colours:define
    return 0
}

colours:define() {
    if [[ "$COLOURS_ON" = false ]]; then

        export CRED=''
        export CGRN=''
        export CYEL=''
        export CBLU=''
        export CPUR=''
        export CTEA=''

        export CBRED=''
        export CBGRN=''
        export CBYEL=''
        export CBBLU=''
        export CBPUR=''
        export CBTEA=''

        export HLRED=''
        export HLGRN=''
        export HLYEL=''
        export HLBLU=''
        export HLPUR=''
        export HLTEA=''

        export CDEF=''

    else

        export CRED=$(echo -e "\033[0;31m")
        export CGRN=$(echo -e "\033[0;32m")
        export CYEL=$(echo -e "\033[0;33m")
        export CBLU=$(echo -e "\033[0;34m")
        export CPUR=$(echo -e "\033[0;35m")
        export CTEA=$(echo -e "\033[0;36m")

        export CBRED=$(echo -e "\033[1;31m")
        export CBGRN=$(echo -e "\033[1;32m")
        export CBYEL=$(echo -e "\033[1;33m")
        export CBBLU=$(echo -e "\033[1;34m")
        export CBPUR=$(echo -e "\033[1;35m")
        export CBTEA=$(echo -e "\033[1;36m")

        export HLRED=$(echo -e "\033[41m")
        export HLGRN=$(echo -e "\033[42m")
        export HLYEL=$(echo -e "\033[43m")
        export HLBLU=$(echo -e "\033[44m")
        export HLPUR=$(echo -e "\033[45m")
        export HLTEA=$(echo -e "\033[46m")

        export CDEF=$(echo -e "\033[0m")

    fi
}

colours:auto

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'true' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'true' to enable command echoing
#
###/doc

: ${MODE_DEBUG=false}
: ${MODE_DEBUG_VERBOSE=false}

# Internal
function out:buffer_initialize {
    OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "true"
###/doc
function out:debug {
    if [[ "$MODE_DEBUG" = true ]]; then
        echo "${CBBLU}DEBUG: $CBLU$*$CDEF" 1>&2
    fi
}

### out:debug:fork [MARKER] Usage:bbuild
#
# Pipe the data coming through stdin to stdout
#
# If debug mode is on, *also* write the same data to stderr, each line preceded by MARKER
#
# Insert this debug fork into pipes to see their output
#
###/doc
function out:debug:fork {
    if [[ "$MODE_DEBUG" = true ]]; then
        local MARKER="${1:-DEBUG: }"; shift || :

        cat - | sed -r "s/^/$MARKER/" | tee -a /dev/stderr
    else
        cat -
    fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
    echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
    echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
    OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
    [[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

    [[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

    for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
        "$@" "$buffer_line"
    done

    out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
    local ERCODE=127
    local numpat='^[0-9]+$'

    if [[ "$1" =~ $numpat ]]; then
        ERCODE="$1"; shift || :
    fi

    echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
    exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
    echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

### out:dump Usage:bbuild
#
# Dump stdin contents to console stderr. Requires debug mode.
#
# Example
#
# 	action_command 2>&1 | out:dump
#
###/doc

function out:dump {
    echo -n "${CBPUR}$*" 1>&2
    echo -n "$CPUR" 1>&2
    cat - 1>&2
    echo -n "$CDEF" 1>&2
}

### out:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires MODE_DEBUG set to true
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Press return to continue execution.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
###/doc

function out:break {
    [[ "$MODE_DEBUG" = true ]] || return 0

    echo -en "${CRED}BREAKPOINT: $* >$CDEF " >&2
    read
    if [[ "$REPLY" =~ quit|exit|stop ]]; then
        out:fail "ABORT"
    fi
}

if [[ "$MODE_DEBUG_VERBOSE" = true ]]; then
    set -x
fi
##bash-libs: autohelp.sh @ 75ff4139-modified (1.1)

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#    ### <title> Usage:help
#    #
#    # <some content>
#    #
#    # end with "###/doc" on its own line (whitespaces before
#    # and after are OK)
#    #
#    ###/doc
#
# You can set a different help section by specifying a subsection
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
#
###/doc

HELPCHAR='#'

function autohelp:print {
    local SECTION_STRING="${1:-}"; shift || :
    local TARGETFILE="${1:-}"; shift || :
    [[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
    [[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
                echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
    echo ""
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
function autohelp:paged {
    : ${PAGER=less}
    autohelp:print "$@" | $PAGER
}

### autohelp:check Usage:bbuild
#
# Automatically print help and exit if "--help" is detected in arguments
#
# Example use:
#
#    #!/bin/bash
#
#    ### Some help Usage:help
#    #
#    # Some help text
#    #
#    ###/doc
#
#    #%include autohelp.sh
#
#    main() {
#        autohelp:check "$@"
#
#        # now add your code
#    }
#
#    main "$@"
#
###/doc
autohelp:check() {
    if [[ "$*" =~ --help ]]; then
        cols="$(tput cols)"
        autohelp:print | fold -w "$cols" -s || autohelp:print
        exit 0
    fi
}

function argcheck {
    local arg="$1"; shift

    if [[ -z "$arg" ]]; then
        out:fail "Please specify $*"
    fi
}

function view_cert {
    [[ -f "$1" ]] || out:fail "No such file [$1]"

    if grep -q "BEGIN CERTIFICATE REQUEST" "$1"; then
        openssl req -text -noout -verify -in "$1"

    else
        openssl x509 -text -noout -in "$1"
    fi
}

function fetch_cert {
    local connectstring="$domain:$port"

    if [[ -f "$connectstring" ]]; then
        echo "$connectstring"
        return
    fi

    echo | (set -x ; openssl s_client -servername "$domain" -connect "$connectstring" ) | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > "$tmpcert" || out:fail "Could not connect to [$domain] on [$port]"
}

function determine_port_from_scheme {
    [[ -n "${scheme:-}" ]] || {
        port=443
        return 0
    }

    case "$scheme" in
    https)
        port=443 ;;
    ssh)
        port=22 ;;
    ldaps)
        port=636 ;;
    ftps)
        port=990 ;;
    *)
        out:fail "Cannot extrapolate port for $scheme" ;;
    esac
}

function get_port() {
    if [[ "$domain" =~ ^(.+?):([0-9]+)$ ]]; then
        port="${BASH_REMATCH[2]}"
        domain="${BASH_REMATCH[1]}"
    fi

    if [[ -z "${port:-}" ]]; then
        determine_port_from_scheme
    fi
}

function get_domain_and_scheme {
    domain="$target"
    [[ ! -f "$target" ]] || out:fail "[$target] is a file"

    # Blat scheme and path
    if [[ "$domain" =~ ^([a-zA-Z0-9]+):// ]]; then
        scheme="${BASH_REMATCH[1]}"
        domain="${domain#$scheme://}"
        domain="${domain%%/*}"
    fi
}

cert-getter:main() {
    cm:helpcheck cert-getter "$@"

    local action="$1"; shift
    local target="$1"; shift

    argcheck "$action" "action (view|fetch)"
    argcheck "$target" "URL or cert file"

    case "$action" in
    fetch)
        get_domain_and_scheme
        get_port
        tmpcert="${domain}-fetched.cer"
        fetch_cert
        ;;
    view)
        view_cert "$target"
        ;;
    *)
        out:fail Invalid action
        ;;
    esac
}

##bash-libs: safe.sh @ 75ff4139-modified (1.1)

### Safe mode Usage:bbuild
#
# Set safe mode options
#
# * Script bails on error
# * Accessing a variable that is not set is an error
# * If a file glob does not expand, cause an error condition
# * If a component of a pipe fails, the entire pipe is a failure
#
###/doc

set -eufo pipefail
##bash-libs: searchpaths.sh @ 75ff4139-modified (1.1)


# FIXME - set function signature in head of help
### searchpaths:file_from PATHDEF FILE Usage:bbuild
#
# Locate a file along a search path.
#
# EXAMPLE
#
# The following will look for each of the files
#  in order of preference of a local lib directory, a profile-wide one, then a system-
#  wide one.
#
#    MYPATH="./lib:$HOME/.local/lib:/usr/local/lib"
# 	searchpaths:file_from "$MYPATH" file
#
# Echoes the path of the first file found.
#
# Returns 1 on failure to find any file.
#
###/doc

function searchpaths:file_from {
    local PATHS="$1"; shift || :
    local FILE="$1"; shift || :

    out:debug "Looking for file [$FILE] amongst [$PATHS]"

    for path in $(echo "$PATHS"|tr ':' ' '); do
        out:debug "Try path: $path"
        local fpath="$path/$FILE"
        if [[ -f "$fpath" ]]; then
            echo "$fpath"
            return 0
        else
            out:debug "No $fpath"
        fi
    done
    return 1
}
##bash-libs: vars.sh @ 75ff4139-modified (1.1)

### Vars library Usage:bbuild
#
# Functions for checking variables
#
###/doc

### vars:require VARNAME ... Usage:bbuild
#
# Check a list of environment variables such that none are non-empty.
#
# If variables are empty/not set, the name is echoed.
#
# Returns the number of missing variables.
#
#    myvarA=one
#    myvarB=
#    myvarC=three
#
#    missing="$(vars:require myvarA myvarB myvarC)"
#
#    if [[ -n "$missing" ]]; then
#        out:fail "Variables were not set : [$missing]"
#    fi
#
###/doc

vars:require() {
    local missing=(:)

    for varname in "$@"; do
        echo "[[ -n "\$$varname" ]]" | bash || {
            missing[${#missing[@]}]="$varname"
        }
    done

    missing=("${missing[@]:1}")

    echo "${missing[*]}"
    return "${#missing[@]}"
}

CERTMAKER_confpaths=".:$HOME/.config/certmaker:/etc/certmaker"

cm:config:load_config() {
	local conffile="$(searchpaths:file_from "$CERTMAKER_confpaths" certmaker.config)"

	if [[ -z "$conffile" ]]; then
		out:fail "No config file found."
	fi

	. "$conffile"
}

cm:config:get_temp() {
    echo "$cnftemplates/$1.cnf"
}

cm:template() {
    local fromfile
    local target="$1"; shift
    local outfile="${1:-}"; shift || :

    case "$target" in
    ca|host)
        fromfile="$(cm:config:get_temp "$target")"
        [[ -n "${outfile:-}" ]] || outfile="./$(basename "$fromfile")"

        sed "
        s|%CASTOREDIR%|$castore|
        " "$fromfile" > "$outfile"
        ;;
    *)
        out:fail "No template for $target"
        ;;
    esac
}
##bash-libs: bincheck.sh @ 75ff4139-modified (1.1)

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
    local BINEXE=
    for binname in "$@"; do
        # Some implementations of `which` print error messages
        # Not useful here.
        BINEXE=$(which "$binname" 2>/dev/null)

        if [[ -n "$BINEXE" ]]; then
            echo "$BINEXE"
            return 0
        fi
    done
    return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
    [[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
    local binname="$1"; shift || :

    [[ "$binname" =~ / ]] && { 
        # A relative path cannot be resolved, just check existence
        [[ -e "$binname" ]] && echo "$binname" || return 1

    } || binname="$(which "$binname" 2>/dev/null)"

    # `which` failed
    [[ -n "$binname" ]] || return 1

    [[ -h "$binname" ]] && {

        local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
        bincheck:path "$pointedname" ; return "$?"
    
    } || echo "$binname"
}

::() {
    [[ -n "$*" ]] || out:fail "No command specified"

	echo  "${CBTEA}$*${CDEF}"

	if [[ "${DRYRUN:-}" != true ]]; then
		"$@" || out:fail "$?"
	fi
}

# Attempt to use a default editor
# 
# If EDITOR is not set,
#  first try emacs - if present, it was probably deliberately installed
#  then try to use the easiest editor (nano)
#  then try to use vim
#  finally fallback to vi
cm:util:edit() {
    local editor
	if [[ -z "${EDITOR:-}" ]]; then
        for editor in nano emacs vim vi; do 
            if bincheck:has "$editor"; then
                EDITOR="$(which "$editor")"
            fi
        done
    fi

	"$EDITOR" "$1"
}

### New Certificate Authority Usage:new-ca
#
# Create and manage a certificate authority
#
# 	certmaker new ca
#
# Ensure you have a `keysize` and `hashalgorithm` entry in your certmaker config
#
# If in doubt, use
#
# 	keysize=4096
# 	hashalgorithm=sha256
#
###/doc

cm:ca:new-ca() {
	cm:helpcheck new-ca "$@" .

	[[ ! -e "$castore" ]] || out:fail "'$castore' must not exist. Archive the existing directory, and try again."

	mkdir -p "$castore"
	chmod 700 "$castore"

	cm:template ca "$castore/authority.cnf"

    cm:util:edit "$castore/authority.cnf"

	:: openssl req -x509 -config "$castore/authority.cnf" -out "$castore/authority.cer" -outform PEM -keyout "$castore/authority.key" -newkey rsa:"$keysize" -"$hashalgorithm"

	out:info "You can store the certificate password in [$castore/pass.txt] for automatic signing"
}
##bash-libs: askuser.sh @ 75ff4139-modified (1.1)

### askuser Usage:bbuild
# Present the user with questions on stderr
###/doc


yespat='^(yes|YES|y|Y)$'
numpat='^[0-9]+$'
rangepat='[0-9]+,[0-9]+'
listpat='^[0-9 ]+$'
blankpat='^ *$'

### askuser:confirm Usage:bbuild
# Ask the user to confirm a closed question. Defaults to no
#
# returns 0 on successfully match 'y' or 'yes'
# returns 1 otherwise
###/doc
function askuser:confirm {
    read -p "$* [y/N] > " 1>&2
    if [[ "$REPLY" =~ $yespat ]]; then
        return 0
    else
        return 1
    fi
}

### askuser:ask Usage:bbuild
# Ask the user to provide some text
#
# Echoes out the entered text
###/doc
function askuser:ask {
    read -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:password Usage:bbuild
# Ask the user to enter a password (does not echo what is typed)
#
# Echoes out the entered text
###/doc
function askuser:password {
    read -s -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:choose_multi Usage:bbuild
# Allows the user to choose from multiple choices
#
# askuser:chose_multi MESG CHOICESTRING
#
#
# MESG is a single string token that will be displayed as prompt
#
# CHOICESTRING is a comma-separated, or newline separated, or "\\n"-separated token string
#
# Equivalent strings include:
#
# * `"a\\nb\\nc"` - quoted and explicit newline escapes
# * `"a,b,c"` - quoted and separated with commas
# * `a , b , c` - not quoted, separated by commas
# * `a`, `b` and `c` on their own lines
#
# User input:
#
# User can choose by selecting
#
# * a single item by number
# * a range of numbers (4,7 for range 4 to 7)
# * or a string that matches the pattern
#
# All option lines that match will be returned, one per line
#
# If the user selects nothing, then function returns 1 and an empty stdout
###/doc
function askuser:choose_multi {
    local mesg=$1; shift || :
    local choices=$(echo "$*"|sed -r 's/ *, */\n/g')
    out:debug "CHOICES: $choices"

    out:info "$mesg:" 
    local choicelist="$(echo -e "$choices"|egrep '^' -n| sed 's/:/: /')"
    echo "$choicelist" 1>&2
    
    local sel=$(askuser:ask "Choice")
    if [[ "$sel" =~ $blankpat ]]; then
        return 1

    elif [[ "$sel" =~ $numpat ]] || [[ "$sel" =~ $rangepat ]]; then
        out:debug "Number choice [$sel]"
        echo -e "$choices" | sed -n "$sel p"
    
    elif [[ "$sel" =~ $listpat ]]; then
        echo "$choicelist" | egrep "^${sel// /|}:" | sed -r 's/^[0-9]+: //'

    else
        out:debug "Pattern choice [$sel]"
        echo -e "$choices"  |egrep "$(echo "$sel"|tr " " '|')"
    fi
    return 0
}

### askuser:choose Usage:bbuild
# Ask the user to choose an item
#
# Like askuser:choose_multi, but will loop if the user selects more than one item
#
# If the user provides no entry, returns 1
#
# If the user chooses one item, that item is echoed to stdout
###/doc
function askuser:choose {
    local mesg=$1; shift || :
    while true; do
        local thechoice="$(askuser:choose_multi "$mesg" "$*")"
        local lines=$(echo -n "$thechoice" | grep '$' -c)
        if [[ $lines = 1 ]]; then
            echo "$thechoice"
            return 0
        elif [[ $lines = 0 ]]; then
            return 1
        else
            out:warn "Too many results"
        fi
    done
}

### CSR Signing Usage:sign
#
# Sign a known host or csr
#
# 	certmaker sign host HOSTNAME
#
# 	certmaker sign csr CSRFILE
#
###/doc

cm:sign() {
	cm:helpcheck sign "$@"
	
	local target="${1:-}"; shift || out:fail "Specify target to sign"

    if [[ -f "$target" ]]; then
		cm:sign:csr "$target" "$@"
    else
		cm:sign:host "$target" "$@"
    fi
}

cm:sign:csr() {
	local csrfile certfile opssl_opts passfile passin
	csrfile="$1"; shift
	certfile="${csrfile%.*}.cer"

	cm:sign:overwrite_check "$certfile"

	files:ensure_file "$castore/index.txt"
	files:ensure_file "$castore/serial.txt" '01'

    passfile="$castore/pass.txt"

    opssl_opts=( -config "$castore/authority.cnf" -policy signing_policy -extensions signing_req -out "$certfile" -infiles "$csrfile")

	# Switch to batch mode when password file exists
    if [[ -f "$passfile" ]]; then
        :: openssl ca -batch -passin "file:$passfile" "${opssl_opts[@]}"
    else
        :: openssl ca "${opssl_opts[@]}"
    fi
}

cm:sign:host() {
    local host_name hostd
    host_name="$1"; shift
    hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "No such host profile '$host_name'"

    cm:sign:csr "$hostd/$host_name.csr" "$hostd/$host_name.cer"
}

cm:sign:overwrite_check() {
	local certfile="$1"; shift
	
	[[ -f "$certfile" ]] || return 0

	askuser:confirm "${CYEL}Overwrite '$certfile'?$CDEF" || out:fail "Abort."

	rm "$certfile" || out:fail "Could not remove '$certfile'"
}


files:ensure_file() {
	local target="$1"; shift
	local tdir="$(dirname "$target")"

	[[ -d "$tdir" ]] || mkdir -p "$tdir"

	[[ -f "$target" ]] || echo -n "$*" > "$target"
}

### New registered host Usage:new-host
#
# Create a new stored host for certfiying
#
# Generates a key + CSR pair stored against the name
#
# 	certmaker new host HOST
#
###/doc

cm:host:new-host() {
	cm:helpcheck new-host "$@"

	if [[ -z "$*" ]]; then
		out:fail "You need to specify a name for the host configuration. Try adding '--help'"
	fi

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ "$myhost" =~ ^[a-zA-Z0-9_.-]+$ ]] || out:fail "Host name can only contain letters, numbers, underscore, period and dash."

	[[ ! -d "$myhostd" ]] || out:fail "Host '$myhost' already exists."

	mkdir -p "$myhostd"

	cm:template host "$myhostd/$myhost.cnf"
}
### New entity Usage:new
#
# Create a new Certificate Authority, or Host
#
#   certmaker new host HOSTNAME
#
#   certmaker new ca CACONF
#
# You can generate a CACONF file with
#
#   certmaker template ca [CACONF]
#
###/doc

cm:new() {
    cm:helpcheck new "$@"

	local target="$1"; shift

	case "$target" in
	ca)
		cm:ca:new-ca "$@"
		;;
	host)
		cm:host:new-host "$@"
		;;
	*)
		out:fail "Unknown target for new: '$target'"
		;;
	esac
}
### CSR Regenration Usage:renew
#
# (Re-)generate key for the host or config.
#
#	certmaker renew key CONFIG [KEYFILE]
#	certmaker renew key HOST
#
# (Re-)generate CSR for the host or key+config file pair
#
#	certmaker renew csr KEYFILE CONFIG [CSRFILE]
#	certmaker renew csr HOST
#
###/doc

cm:renew() {
    cm:helpcheck renew "$@"

    local rtype="${1:-}" ; shift || out:fail "Specify renewal type"
    local filehost="${1:-}" ; shift || out:fail "Specify target file or host"

    case "$rtype" in
    csr|key)
        if [[ -f "$filehost" ]]; then
            cm:renew:${rtype}-file "$filehost" "$@"
        else
            cm:renew:${rtype}-host "$filehost" "$@"
        fi
        ;;
    *)
        out:fail "Unknown renewal type '$rtype'"
        ;;
    esac
}

cm:renew:key-file() {
    local config keyfile

    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"
    keyfile="${1:-}"; shift || {
        keyfile="${config%.*}.key"
    }

    :: openssl genrsa -out "$keyfile" "$keysize" -config "$config"
}

cm:renew:key-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:key-file "$hostd/${host_name}.cnf" "$hostd/${host_name}.key"
}

cm:renew:csr-file() {
    local keyfile csrfile config
    keyfile="${1:-}"; shift || out:fail "Specify an input key file"
    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"

    csrfile="${1:-}"; shift || {
        csrfile="${keyfile%.*}.csr"
    }

    :: openssl req -new -key "$keyfile" -out "$csrfile" -config "$config"
}

cm:renew:csr-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:csr-file "$hostd/${host_name}.key" "$hostd/${host_name}.cnf" "$hostd/${host_name}.csr"
}
cm:paths() {
    local host_name hostd

    host_name="${1:-}"; shift || {
        cm:paths:list
        return
    }

    hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "Unknown host profile '$host_name'"

    ls "$hostd/$host_name."{key,cer}
}

cm:paths:list() {
    find "$hoststore" -name '*.cnf' -exec dirname {} \; | sed "s|$hoststore/||"
}
### Quick mode Usage:quick
#
# Set up a base configuration for host certificates; don't add any `DNS.*` entries yet
#
#    certmaker quick --edit
#
# Once you have a base configuration, you can create any number of individual hosts
#
#   certmaker quick PROFILENAME DOMAINS ...
#
# The profile name is a name for the store of the config, key, CSR and certificate files.
#
# DOMAINS ... is only required when first creating the profile ; to subsequently edit the domains the certificate will certify for, run
#
#   certmaker edit PROFILENAME
#
#
###/doc

cm:quick() {
    cm:helpcheck quick "$@"

    if [[ "$1" = "--edit" ]]; then
        cm:quick:edit

    else
        cm:quick:host "$@"
    fi
}

cm:quick:edit() {
    local quick_template
    quick_template="$hoststore/quick.cnf"
    if [[ ! -f "$quick_template" ]]; then
        cm:template host "$quick_template"
    fi

    cm:util:edit "$quick_template"
}

cm:quick:host() {
    local host_name
    host_name="${1:-}"; shift || out:fail "Specify a host name"

    cm:quick:ensure_host "$host_name" "$@"

    cm:quick:ensure_key "$host_name"

    cm:renew:csr-host "$host_name"

    cm:sign:host "$host_name"

    # Echo the colour byte to stderr
    # but the keys to stdout
    # in case user is grepping for the files
    echo -n "$CBBLU" >&2
    echo "$(cm:paths "$host_name")"
    echo -n "$CDEF" >&2
}

cm:quick:ensure_host() {
    local host_name hostd hostconf quick_template x
    host_name="${1:-}"; shift
    hostd="$hoststore/$host_name"
    hostconf="$hostd/$host_name.cnf"

    quick_template="$hoststore/quick.cnf"
    [[ -f "$quick_template" ]] || out:fail "Quick template not yet set - run 'certmaker quick --edit' to create a global template first"

    if [[ ! -f "$hostconf" ]]; then

        askuser:confirm "Create host '$host_name' ?"
        [[ -n "$*" ]] || out:fail "You need to also specify domains to add."

        cm:host:new-host "$host_name"
        cp "$quick_template" "$hostconf"

        for x in $(seq 1 $#); do
            echo "DNS.$x = $1" >> "$hostconf"
            shift
        done
    fi
}

cm:quick:ensure_key() {
    local host_name hostd hostconf
    host_name="${1:-}"; shift
    hostd="$hoststore/$host_name"

    if [[ ! -f "$hostd/$host_name.key" ]]; then
        cm:renew:key-host "$host_name"
    fi
}

### Edit host config Usage:edit
#
#	certmaker edit HOST
#
# Edit the SSL config for the registered host
#
###/doc

cm:edit() {
	cm:helpcheck edit "$@"

    if [[ "$1" = --ca ]]; then
        cm:util:edit "$castore/authority.cnf"
    else
        cm:edit:host "$@"
    fi
}

cm:edit:host() {

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ -d "$myhostd" ]] || out:fail "Host '$myhost' does not exist."

    cm:util:edit "$myhostd/$myhost.cnf"
}

cm:main() {
    # Do not autohelp:check here, as it would override sub-topic help
    [[ -n "$*" ]] || {
        autohelp:print
        exit 0
    }
    action="$1"; shift || :

    case "$action" in
        view|fetch)
            cert-getter:main "$action" "$@"
            return
            ;;
        help|--help)
            cm:guide
            return 0
            ;;
    esac

    cm:config:load_config

    cm:checkuser

    case "$action" in
        template)
            cm:template "$@"
            ;;
        new)
            cm:new "$@"
            ;;
        edit)
            cm:edit "$@"
            ;;
        sign)
            cm:sign "$@"
            ;;
        renew)
            cm:renew "$@"
            ;;
        paths)
            cm:paths "$@"
            ;;
        quick)
            cm:quick "$@"
            ;;
        *)
            autohelp:print
            out:fail "Unknown action $action"
            ;;
    esac
}

cm:checkuser() {
    local iam=$(whoami)

    [[ "$cmuser" = "$iam" ]] || {
        out:warn "Loaded Certmaker config was installed for '$cmuser'."
        askuser:confirm "Continue?"
    }
}

cm:helpcheck() {

    local section="$1"; shift

    if [[ "$*" =~ --help ]] || [[ -z "$*" ]]; then
        autohelp:print "$section"
        exit 0
    fi

    return 0
}

cm:main "$@"
