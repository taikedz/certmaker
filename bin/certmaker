#!/usr/bin/env bash

# This software is Free Software
# (C) Tai Kedzierski 2017-2018
#
# It is provided to you under the terms of the GNU General Public License v3
# https://www.gnu.org/licenses/gpl-3.0.html


### certmaker Usage:help
#
# Tool to generate a CA, generate keys and CSRs, and sign CSRs
#
# From https://github.com/taikedz/CertMaker
#
# Further below are /all/ the available commands, but you probably only want one of the following:
#
#   certmaker new ca
#   certmaker quick --edit
#   certmaker quick HOST DOMAIN ...
#   certmaker paths [HOST]
#   certmaker view CERTFILE
#
# Run
#
#   certmaker help
#
# for a quick-start tutorial.
#
#
# 
# ### Listing profiles
#
# List host profiles
#
#   certmaker paths
#
# List key and certificate for a host profile
#
#   certmaker paths HOST
#
#
# ### Creating and signing profiles (central management)
#
# Create a new host profile, edit it:
#
#     certmaker new host HOST
#     certmaker edit HOST
#
# Regenerate host profile assets
#
#   certmaker renew key { HOST | CONFIG [KEYFILE] }
#   certmaker renew csr { HOST | KEYFILE CONFIG [CSRFILE] }
#
# Sign a host profile or CSR file:
#
#     certmaker sign { HOST | CSRFILE [CERTFILE] }
#
#
# ### Generate new CA or CSRs
#
# Create a new CA:
#
#     certmaker new ca
#
# Create a new CSR:
#
#     certmaker csr CSRNAME [FQDN ...]
#
# ### Certificate viewing and fetching
#
# Fetch a site's certificate, and view a certificate file
#
#   certmaker fetch { DOMAIN | URL }
#
#   certmake view CERTFILE
#
#
###/doc
cm:guide() {
cat <<'ENDOFEXTENDEDGUIDE' | less
CertMaker
===========

A tool to create an OpenSSL certificate authority, and generate certificates, for use on internal networks.

The tool is written with three uses cases in mind:

* As an *internal* CA tool that will act as CA and manage certificate/key pairs centrally, distributing them to target servers
    * the `quick` command facilitates this workflow
* As a *CSR client* tool for generating CSRs to be sent to CAs
* As a plain internal CA that can sign individual CSRs

If you are deploying a public-facing web site, please consider using [Let's Encrypt](https://letsencrypt.org)


Quick Start
===========

Setup

    sudo ./install.sh

    # Adjust the ca_distinguished_name section
    sudo certmaker new ca

    # Adjust the host template's server_distinguished_name section
    sudo certmaker quick --edit

Create host key and certificate

    sudo certmaker quick new-host myhost.net

Renew host certificate, and create TGZ of asset files

    sudo certmaker quick new-host
    certmaker paths tgz new-host

Copy the assets to the target host.


Detailed walk-through
=====================


Install certmaker
-----------------

    sudo ./install.sh

Configuration is palced in `/etc/certmaker/certmaker.config`

If you do not install as root, it is placed in `~/.config/certmaker/certmaker.config`. Note that if a root installation already exists, you cannot install for a non-root user.

Ensure your `EDITOR` environment variable is set to your preferred text editor; if it is not set, CertMaker will try to use Emacs, nano, vim or vi.

New CA
---------

Sets up a new CA config, and opens an editor; specifically ensure you update the organisation country and details. You can also edit the `default_days` property to specify the number of days a newly signed certificate is valid for. You will be prompted for a password for the key.

    certmaker new ca

It is possible to save a password file in plaintext in `$CERTMAKERCONFIG/ca/pass.txt` to allow running in batch mode; treat this with caution as this means that your password will be lying in plain text on the filesystem.

If your CA is going to be used to centrally manage certificates and keys, set up a generic hosts config which will be used as a template for managed hosts

    certmaker quick --edit


Centrally managed hosts
-----------------------

If you want the CA to manage both keys and certificates for host machines, use these steps. In this scenario, the CA is responsible for creating both the keys and the certificates that will be placed on host machines.

Create a new host profile, specifying the domains to certify for - you will be prompted to edit it, and will then be given paths to a key and certificate file as a result.

    certmaker quick myhost DOMAIN ...

Re-run the command any time you want to renew the certificate. You will need to copy the new certificate to the desired host machine to replace the old certificate.

If you want to add new domains, you will need to edit the host config and add them manually, then re-generate the signed certificate:

    certmaker edit myhost
    certmaker quick myhost

Generic CSR and CA activities
-----------------------------

###    Target host

If you simply want to create a CSR for your web host, to send to a remote CA for signing:

	certmaker csr mysite mysite.company.net

This will create an OpenSSL config (annotated) and key, along with the corresponding CSR file `myhost.csr` to send to the CA


###    Certificate Authority

On receipt of a CSR, simply use the `sign csr` command:

    certmaker sign csr CSRFILE [OUTCERTFILE]

This will generate a certificate file as specified, or with the same base name as the CSR, to send back to the requestor.



Sub Commands
============


fetch/view - to retrieve and inspect certificates
-------------------------------------------------

###    `fetch`

You can fetch the certificate of a live site using

    certmaker fetch URL

Supported URLs include `https://`, `ldaps://` and `ftps://`

###    `view`

You can inspect the contents of a certificate PEM file (typically a block of base-64 data bounded with `BEGIN` and `END` statements) using

    certmaker view CERTFILE

Certificates generated by CertMaker are always PEM files.



jks - Java Keystore and PKCS12 store manipulation
-------------------------------------------------

You can manipulate a Java Key Store or PKCS12 key store using the `jks` subcommand.


When transferring a Key and Certificate pair to a Java target, you should hand off a PKCS12 file ratherm than PEM files

    certmaker jks generate -k generatedkeys.p12 -a defaultalias -f KEYFILE


You can then load the key into the Java host's keystore using

    certmaker jks add-key -k KEYSTORE -a ALIAS -f generatedkeys.p12


You can view a keystore contents using

    certmaker jks view -k KEYSTORE [-a ALIAS]

See `certmaker jks --help` for more info and commands.
ENDOFEXTENDEDGUIDE
}
### Certificate Getter Usage:cert-getter
#
# Certificate fetch and view agent.
#
#     certmaker fetch [SCHEME://]DOMAIN[:PORT]
#     certmaker view CERTFILE
#
# Fetch the certificate for a HTTPS domain to a file, or view the contents of a certificate file
#
# DOMAIN is the domain name to check, by default on port 443
#
# You can specify an alternative port, for example
#
#     certmaker fetch mydomain.net:8443
#
###/doc

##bash-libs: tty.sh @ bf310b32 (1.4.1)

tty:is_ssh() {
    [[ -n "$SSH_TTY" ]] || [[ -n "$SSH_CLIENT" ]] || [[ "$SSH_CONNECTION" ]]
}

tty:is_pipe() {
    [[ ! -t 1 ]]
}

##bash-libs: colours.sh @ bf310b32 (1.4.1)

### Colours for terminal Usage:bbuild
# A series of shorthand colour flags for use in outputs, and functions to set your own flags.
#
# Not all terminals support all colours or modifiers.
#
# Example:
# 	
# 	echo "${CRED}Some red text ${CBBLU} some blue text. $CDEF Some text in the terminal's default colour")
#
# Preconfigured colours available:
#
# CRED, CBRED, HLRED -- red, bright red, highlight red
# CGRN, CBGRN, HLGRN -- green, bright green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bright yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bright blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bright purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bright teal, highlight teal
# CBLA, CBBLA, HLBLA -- black, bright red, highlight red
# CWHI, CBWHI, HLWHI -- white, bright red, highlight red
#
# Modifiers available:
#
# CBON - activate bright
# CDON - activate dim
# ULON - activate underline
# RVON - activate reverse (switch foreground and background)
# SKON - activate strikethrough
# 
# Resets available:
#
# CNORM -- turn off bright or dim, without affecting other modifiers
# ULOFF -- turn off highlighting
# RVOFF -- turn off inverse
# SKOFF -- turn off strikethrough
# HLOFF -- turn off highlight
#
# CDEF -- turn off all colours and modifiers(switches to the terminal default)
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
# If the session is detected as being in a pipe, colours will be turned off.
#   You can override this by calling `colours:check --color=always` at the start of your script
#
###/doc

### colours:check ARGS ... Usage:bbuild
#
# Check the args to see if there's a `--color=always` or `--color=never`
#   and reload the colours appropriately
#
#   main() {
#       colours:check "$@"
#
#       echo "${CGRN}Green only in tty or if --colours=always !${CDEF}"
#   }
#
#   main "$@"
#
###/doc
colours:check() {
    if [[ "$*" =~ --color=always ]]; then
        COLOURS_ON=true
    elif [[ "$*" =~ --color=never ]]; then
        COLOURS_ON=false
    fi

    colours:define
    return 0
}

### colours:set CODE Usage:bbuild
# Set an explicit colour code - e.g.
#
#   echo "$(colours:set "33;2")Dim yellow text${CDEF}"
#
# See SGR Colours definitions
#   <https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters>
###/doc
colours:set() {
    # We use `echo -e` here rather than directly embedding a binary character
    if [[ "$COLOURS_ON" = false ]]; then
        return 0
    else
        echo -e "\033[${1}m"
    fi
}

colours:define() {

    # Shorthand colours

    export CBLA="$(colours:set "30")"
    export CRED="$(colours:set "31")"
    export CGRN="$(colours:set "32")"
    export CYEL="$(colours:set "33")"
    export CBLU="$(colours:set "34")"
    export CPUR="$(colours:set "35")"
    export CTEA="$(colours:set "36")"
    export CWHI="$(colours:set "37")"

    export CBBLA="$(colours:set "1;30")"
    export CBRED="$(colours:set "1;31")"
    export CBGRN="$(colours:set "1;32")"
    export CBYEL="$(colours:set "1;33")"
    export CBBLU="$(colours:set "1;34")"
    export CBPUR="$(colours:set "1;35")"
    export CBTEA="$(colours:set "1;36")"
    export CBWHI="$(colours:set "1;37")"

    export HLBLA="$(colours:set "40")"
    export HLRED="$(colours:set "41")"
    export HLGRN="$(colours:set "42")"
    export HLYEL="$(colours:set "43")"
    export HLBLU="$(colours:set "44")"
    export HLPUR="$(colours:set "45")"
    export HLTEA="$(colours:set "46")"
    export HLWHI="$(colours:set "47")"

    # Modifiers
    
    export CBON="$(colours:set "1")"
    export CDON="$(colours:set "2")"
    export ULON="$(colours:set "4")"
    export RVON="$(colours:set "7")"
    export SKON="$(colours:set "9")"

    # Resets

    export CBNRM="$(colours:set "22")"
    export HLOFF="$(colours:set "49")"
    export ULOFF="$(colours:set "24")"
    export RVOFF="$(colours:set "27")"
    export SKOFF="$(colours:set "29")"

    export CDEF="$(colours:set "0")"

}

colours:auto() {
    if tty:is_pipe ; then
        COLOURS_ON=false
    else
        COLOURS_ON=true
    fi

    colours:define
    return 0
}

colours:auto

##bash-libs: out.sh @ bf310b32 (1.4.1)

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
    echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
    echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
    OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

# Internal
function out:buffer_initialize {
    OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
    [[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

    [[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

    for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
        "$@" "$buffer_line"
    done

    out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
    local ERCODE=127
    local numpat='^[0-9]+$'

    if [[ "$1" =~ $numpat ]]; then
        ERCODE="$1"; shift || :
    fi

    echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
    exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
    echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

##bash-libs: autohelp.sh @ bf310b32 (1.4.1)

### Autohelp Usage:bbuild
#
# Autohelp provides some simple facilities for defining help as comments in your code.
# It provides several functions for printing specially formatted comment sections.
#
# Write your help as documentation comments in your script
#
# To output a named section from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script, or specified file, to stdout
#
# A help comment looks like this:
#
#    ### <title> Usage:help
#    #
#    # <some content>
#    #
#    # end with "###/doc" on its own line (whitespaces before
#    # and after are OK)
#    #
#    ###/doc
#
# It can then be printed from the same script by simply calling
#
#   autohelp:print
#
# You can print a different section by specifying a different name
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable.
# Typically, you might want to print comments you set in a INI config file, for example
#
# 	HELPCHAR=";" autohelp:print help config-file.ini
# 
# Which would then find comments defined like this in `config-file.ini`:
#
#   ;;; Main config Usage:help
#   ; Help comments in a config file
#   ; may start with a different comment character
#   ;;;/doc
#
#
#
# Example usage in a multi-function script:
#
#   #!/bin/bash
#
#   ### Main help Usage:help
#   # The main help
#   ###/doc
#
#   ### Feature One Usage:feature_1
#   # Help text for the first feature
#   ###/doc
#
#   feature1() {
#       autohelp:check_section feature_1 "$@"
#       echo "Feature I"
#   }
#
#   ### Feature Two Usage:feature_2
#   # Help text for the second feature
#   ###/doc
#
#   feature2() {
#       autohelp:check_section feature_2 "$@"
#       echo "Feature II"
#   }
#
#   main() {
#       if [[ -z "$*" ]]; then
#           ### No command specified Usage:no-command
#           #No command specified. Try running with `--help`
#           ###/doc
#
#           autohelp:print no-command
#           exit 1
#       fi
#
#       case "$1" in
#       feature1|feature2)
#           "$1" "$@"            # Pass the global script arguments through
#           ;;
#       *)
#           autohelp:check "$@"  # Check if main help was asked for, if so, exits
#
#           # Main help not requested, return error
#           echo "Unknown feature"
#           exit 1
#           ;;
#       esac
#   }
#
#   main "$@"
#
###/doc

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Print the specified section, in the specified file.
#
# If no file is specified, prints for current script file.
# If no section is specified, defaults to "help"
###/doc

HELPCHAR='#'

autohelp:print() {
    local input_line
    local section_string="${1:-}"; shift || :
    local target_file="${1:-}"; shift || :
    [[ -n "$section_string" ]] || section_string=help
    [[ -n "$target_file" ]] || target_file="$0"

    #echo -e "\n$(basename "$target_file")\n===\n"
    local sec_start='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$section_string"'\s*$'
    local sec_end='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
    local in_section=false

    while read input_line; do
        if [[ "$input_line" =~ $sec_start ]]; then
            in_section=true
            echo -e "\n${BASH_REMATCH[1]}\n======="

        elif [[ "$in_section" = true ]]; then
            if [[ "$input_line" =~ $sec_end ]]; then
                in_section=false
            else
                echo "$input_line" | sed -r "s/^\s*$HELPCHAR/ /;s/^  (\S)/\1/"
            fi
        fi
    done < "$target_file"

    if [[ "$in_section" = true ]]; then
            out:fail "Non-terminated help block."
    fi
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
autohelp:paged() {
    : ${PAGER=less}
    autohelp:print "$@" | $PAGER
}

### autohelp:check ARGS ... Usage:bbuild
#
# Automatically print "help" sections and exit, if "--help" is detected in arguments
#
###/doc
autohelp:check() {
    autohelp:check_section "help" "$@"
}

### autohelp:check_section SECTION ARGS ... Usage:bbuild
# Automatically print documentation for named section and exit, if "--help" is detected in arguments
#
###/doc
autohelp:check_section() {
    local section arg
    section="${1:-}"; shift || out:fail "No help section specified"

    for arg in "$@"; do
        if [[ "$arg" =~ --help ]]; then
            cols="$(tput cols)"
            autohelp:print "$section" | fold -w "$cols" -s || autohelp:print "$section"
            exit 0
        fi
    done
}
##bash-libs: runmain.sh @ bf310b32 (1.4.1)

### runmain SCRIPTNAME FUNCTION [ARGUMENTS ...] Usage:bbuild
#
# Runs the function FUNCTION with ARGUMENTS, only if the runtime
# name of the script matches SCRIPTNAME
#
# This allows you include a main-like function in your library
# that only runs if you use your lib as an executabl itself.
#
# For example, an image archiver could be:
#
# 	function archive_images {
# 		tar czf "$1.tgz" "$@"
# 	}
#
# 	runmain archiveimages.sh archive_images "$@"
#
# When included a different script, the runmain call does not fire the lib's function
#
# If the lib is compiled/made executable, and named "archiveimages.sh", the function runs.
#
# This is similar to `if __name__ == "__main__"` clauses in python
#
###/doc

function runmain {
    local required_name="$1"; shift || :
    local funcall="$1"; shift || :
    local scriptname="$(basename "$0")"

    if [[ "$required_name" = "$scriptname" ]]; then
        "$funcall" "$@"
    fi
}

function argcheck {
    local arg="$1"; shift

    if [[ -z "$arg" ]]; then
        out:fail "Please specify $*"
    fi
}

function view_cert {
    [[ -f "$1" ]] || out:fail "No such file [$1]"

    if grep -qP "BEGIN( NEW)? CERTIFICATE REQUEST" "$1"; then
        openssl req -text -noout -verify -in "$1"

    else
        openssl x509 -text -noout -in "$1"
    fi
}

function fetch_cert {
    local connectstring="$domain:$port"

    if [[ -f "$connectstring" ]]; then
        echo "$connectstring"
        return
    fi

    echo | (set -x ; openssl s_client -servername "$domain" -connect "$connectstring" ) | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > "$tmpcert" || out:fail "Could not connect to [$domain] on [$port]"
}

function determine_port_from_scheme {
    [[ -n "${scheme:-}" ]] || {
        port=443
        return 0
    }

    case "$scheme" in
    https)
        port=443 ;;
    ssh)
        port=22 ;;
    ldaps)
        port=636 ;;
    ftps)
        port=990 ;;
    *)
        out:fail "Cannot extrapolate port for $scheme" ;;
    esac
}

function get_port() {
    if [[ "$domain" =~ ^(.+?):([0-9]+)$ ]]; then
        port="${BASH_REMATCH[2]}"
        domain="${BASH_REMATCH[1]}"
    fi

    if [[ -z "${port:-}" ]]; then
        determine_port_from_scheme
    fi
}

function get_domain_and_scheme {
    domain="$target"
    [[ ! -f "$target" ]] || out:fail "[$target] is a file"

    # Blat scheme and path
    if [[ "$domain" =~ ^([a-zA-Z0-9]+):// ]]; then
        scheme="${BASH_REMATCH[1]}"
        domain="${domain#$scheme://}"
        domain="${domain%%/*}"
    fi
}

cert-getter:main() {
    if [[ "$*" =~ --help ]]; then
    	autohelp:print cert-getter
	exit 0
    fi

    local action="${1:-}"; shift || out:fail "Please specify an aciton view or fetch"
    local target="${1:-}"; shift || out:fail "Please specify a target file or domain"

    argcheck "$action" "action (view|fetch)"
    argcheck "$target" "URL or cert file"

    case "$action" in
    fetch)
        get_domain_and_scheme
        get_port
        tmpcert="${domain}-fetched.cer"
        fetch_cert
        ;;
    view)
        view_cert "$target"
        ;;
    *)
        out:fail Invalid action
        ;;
    esac
}

runmain cert-getter.sh cert-getter:main "$@"

##bash-libs: safe.sh @ bf310b32 (1.4.1)

### Safe mode Usage:bbuild
#
# Set global safe mode options
#
# * Script bails if a statement or command returns non-zero status
#   * except when in a conditional statement
# * Accessing a variable that is not set is an error, causing non-zero status of the operation
# * If a file glob does not expand, cause an error condition
# * If a component of a pipe fails, the entire pipe statement returns non-zero
#
# Splitting over spaces
#
# You can also switch space splitting on or off (normal bash default is 'on')
#
# Given a function `foo()` that returns multiple lines, which may each have spaces in them, use safe splitting to return each item into an array as its own item, without splitting over spaces.
#
#   safe:space-split off
#   mylist=(foo)
#   safe:space-split on
#
# Having space splitting on causes statements like `echo "$*"` to print each argument on its own line.
#
###/doc

set -eufo pipefail

safe:space-split() {
    case "$1" in
    off)
        export IFS=$'\t\n'
        ;;
    on)
        export IFS=$' \t\n'
        ;;
    *)
        out:fail "API error: bad use of safe:split - must be 'on' or 'off' not '$1'"
        ;;
    esac
}

##bash-libs: searchpaths.sh @ bf310b32 (1.4.1)

# FIXME - set function signature in head of help
### searchpaths:file_from PATHDEF FILE Usage:bbuild
#
# Locate a file along a search path.
#
# EXAMPLE
#
# The following will look for each of the files
#  in order of preference of a local lib directory, a profile-wide one, then a system-
#  wide one.
#
#    MYPATH="./lib:$HOME/.local/lib:/usr/local/lib"
# 	searchpaths:file_from "$MYPATH" file
#
# Echoes the path of the first file found.
#
# Returns 1 on failure to find any file.
#
###/doc

function searchpaths:file_from {
    local PATHS="$1"; shift || :
    local FILE="$1"; shift || :

    for path in $(echo "$PATHS"|tr ':' ' '); do
        local fpath="$path/$FILE"
        if [[ -f "$fpath" ]]; then
            echo "$fpath"
            return 0
        fi
    done
    return 1
}
##bash-libs: vars.sh @ bf310b32 (1.4.1)

### Vars library Usage:bbuild
#
# Functions for checking variables
#
###/doc

### vars:require RETURNVAR VARNAMES ... Usage:bbuild
#
# Check a list of environment variables such that none are non-empty.
#
# If variables are empty/not set, the name is added to the return holder variable.
#
# Example:
#
#    myvarA=one
#    myvarB=
#    myvarC=three
#
#    if ! vars:require missing_vars myvarA myvarB myvarC ; then
#        echo "The following variables are not set: $missing_vars"
#    fi
#
###/doc

vars:require() {
    local missing_var="${1:-}" ; shift || out:fail "Internal error: no aruments passed for var check"
    local res=0

    for varname in "$@"; do
        . <(echo "[[ -n \"\${$varname:-}\" ]]") || {
            . <(echo "$missing_var=\"\${$missing_var:-} $varname\"")
            res=1
        }
    done

    return "$res"
}

CERTMAKER_confpaths=".:$HOME/.config/certmaker:/etc/certmaker"

cm:config:load_config() {
	local conffile="$(searchpaths:file_from "$CERTMAKER_confpaths" certmaker.config)"

	if [[ -z "$conffile" ]]; then
		out:fail "No config file found."
	fi

	. "$conffile"
}

cm:config:get_temp() {
    echo "$cnftemplates/$1.cnf"
}

### certmaker template {ca|host} [OUTFILE] Usage:template
#
# Create an OpenSSL config file for a CA or a host
#
###/doc

cm:template() {
    cm:helpcheck template "$@"

    local fromfile target outfile
    target="$1"; shift
    outfile="${1:-}"; shift || :

    case "$target" in
    ca|host)
        fromfile="$(cm:config:get_temp "$target")"
        [[ -n "${outfile:-}" ]] || outfile="./$(basename "$fromfile")"

        sed "
        s|%CASTOREDIR%|$castore|
        " "$fromfile" > "$outfile"
        ;;
    *)
        out:fail "No template for $target"
        ;;
    esac
}
##bash-libs: bincheck.sh @ bf310b32 (1.4.1)

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
    local BINEXE=
    for binname in "$@"; do
        # Some implementations of `which` print error messages
        # Not useful here.
        BINEXE=$(which "$binname" 2>/dev/null)

        if [[ -n "$BINEXE" ]]; then
            echo "$BINEXE"
            return 0
        fi
    done
    return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
    [[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
    local binname="$1"; shift || :

    [[ "$binname" =~ / ]] && { 
        # A relative path cannot be resolved, just check existence
        [[ -e "$binname" ]] && echo "$binname" || return 1

    } || binname="$(which "$binname" 2>/dev/null)"

    # `which` failed
    [[ -n "$binname" ]] || return 1

    [[ -h "$binname" ]] && {

        local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
        bincheck:path "$pointedname" ; return "$?"
    
    } || echo "$binname"
}

::() {
    [[ -n "$*" ]] || out:fail "No command specified"

	echo  "${CBTEA}$*${CDEF}"

	if [[ "${DRYRUN:-}" != true ]]; then
		"$@" || out:fail "$?"
	fi
}

# Attempt to use a default editor
# 
# If EDITOR is not set,
#  first try emacs - if present, it was probably deliberately installed
#  then try to use the easiest editor (nano)
#  then try to use vim
#  finally fallback to vi
cm:util:edit() {
    local editor
	if [[ -z "${EDITOR:-}" ]]; then
        for editor in nano emacs vim vi; do 
            if bincheck:has "$editor"; then
                EDITOR="$(which "$editor")"
            fi
        done
    fi

	"$EDITOR" "$1"
}

### New Certificate Authority Usage:new-ca
#
# Create and manage a certificate authority
#
# 	certmaker new ca
#
# Ensure you have a `keysize` and `hashalgorithm` entry in your certmaker config
#
# If in doubt, use
#
# 	keysize=4096
# 	hashalgorithm=sha256
#
###/doc

cm:ca:new-ca() {
	cm:helpcheck new-ca "$@" .

	[[ ! -e "$castore" ]] || out:fail "'$castore' must not exist. Archive the existing directory, and try again."

	mkdir -p "$castore"
	chmod 700 "$castore"

	cm:template ca "$castore/authority.cnf"

    cm:util:edit "$castore/authority.cnf"

	:: openssl req -x509 -config "$castore/authority.cnf" -out "$castore/authority.cer" -outform PEM -keyout "$castore/authority.key" -newkey rsa:"$keysize" -"$hashalgorithm"

	out:info "You can store the certificate password in [$castore/pass.txt] for automatic signing"
}

##bash-libs: askuser.sh @ bf310b32 (1.4.1)

### askuser Usage:bbuild
# Present the user with questions on stderr
###/doc

yespat='^(yes|YES|y|Y)$'
numpat='^[0-9]+$'
rangepat='[0-9]+,[0-9]+'
listpat='^[0-9 ]+$'
blankpat='^ *$'

### askuser:confirm Usage:bbuild
# Ask the user to confirm a closed question. Defaults to no
#
# returns 0 on successfully match 'y' or 'yes'
# returns 1 otherwise
###/doc
function askuser:confirm {
    read -p "$* [y/N] > " 1>&2
    if [[ "$REPLY" =~ $yespat ]]; then
        return 0
    else
        return 1
    fi
}

### askuser:ask Usage:bbuild
# Ask the user to provide some text
#
# Echoes out the entered text
###/doc
function askuser:ask {
    read -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:password Usage:bbuild
# Ask the user to enter a password (does not echo what is typed)
#
# Echoes out the entered text
###/doc
function askuser:password {
    read -s -p "$* : " 1>&2
    echo >&2
    echo "$REPLY"
}

### askuser:choose_multi Usage:bbuild
# Allows the user to choose from multiple choices
#
# askuser:chose_multi MESG CHOICESTRING
#
#
# MESG is a single string token that will be displayed as prompt
#
# CHOICESTRING is a comma-separated, or newline separated, or "\\n"-separated token string
#
# Equivalent strings include:
#
# * `"a\\nb\\nc"` - quoted and explicit newline escapes
# * `"a,b,c"` - quoted and separated with commas
# * `a , b , c` - not quoted, separated by commas
# * `a`, `b` and `c` on their own lines
#
# User input:
#
# User can choose by selecting
#
# * a single item by number
# * a range of numbers (4,7 for range 4 to 7)
# * or a string that matches the pattern
#
# All option lines that match will be returned, one per line
#
# If the user selects nothing, then function returns 1 and an empty stdout
###/doc
function askuser:choose_multi {
    local mesg=$1; shift || :
    local choices=$(echo "$*"|sed -r 's/ *, */\n/g')

    out:info "$mesg:" 
    local choicelist="$(echo -e "$choices"|grep -E '^' -n| sed 's/:/: /')"
    echo "$choicelist" 1>&2
    
    local sel=$(askuser:ask "Choice")
    if [[ "$sel" =~ $blankpat ]]; then
        return 1

    elif [[ "$sel" =~ $numpat ]] || [[ "$sel" =~ $rangepat ]]; then
        echo -e "$choices" | sed -n "$sel p"
    
    elif [[ "$sel" =~ $listpat ]]; then
        echo "$choicelist" | grep -E "^${sel// /|}:" | sed -r 's/^[0-9]+: //'

    else
        echo -e "$choices"  |grep -E "$(echo "$sel"|tr " " '|')"
    fi
    return 0
}

### askuser:choose Usage:bbuild
# Ask the user to choose an item
#
# Like askuser:choose_multi, but will loop if the user selects more than one item
#
# If the user provides no entry, returns 1
#
# If the user chooses one item, that item is echoed to stdout
###/doc
function askuser:choose {
    local mesg=$1; shift || :
    while true; do
        local thechoice="$(askuser:choose_multi "$mesg" "$*")"
        local lines=$(echo -n "$thechoice" | grep '$' -c)
        if [[ $lines = 1 ]]; then
            echo "$thechoice"
            return 0
        elif [[ $lines = 0 ]]; then
            return 1
        else
            out:warn "Too many results"
        fi
    done
}

### CSR Signing Usage:sign
#
# Sign a known host or csr
#
# 	certmaker sign host HOSTNAME
#
# 	certmaker sign csr CSRFILE
#
###/doc

cm:sign() {
	cm:helpcheck sign "$@"
	
	local target="${1:-}"; shift || out:fail "Specify target to sign"

    if [[ -f "$target" ]]; then
		cm:sign:csr "$target" "$@"
    else
		cm:sign:host "$target" "$@"
    fi
}

cm:sign:csr() {
	local csrfile certfile opssl_opts passfile passin
	csrfile="$1"; shift
	certfile="${csrfile%.*}.cer"

	cm:sign:overwrite_check "$certfile"

	files:ensure_file "$castore/index.txt"
	files:ensure_file "$castore/serial.txt" '01'

    passfile="$castore/pass.txt"

    opssl_opts=( -config "$castore/authority.cnf" -policy signing_policy -extensions signing_req -out "$certfile" -infiles "$csrfile")

	# Switch to batch mode when password file exists
    if [[ -f "$passfile" ]]; then
        :: openssl ca -batch -passin "file:$passfile" "${opssl_opts[@]}"
    else
        :: openssl ca "${opssl_opts[@]}"
    fi

    cat "$castore/authority.cer" >> "$certfile" # Generate a fullchain cert
}

cm:sign:host() {
    local host_name hostd
    host_name="$1"; shift
    hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "No such host profile '$host_name'"

    cm:sign:csr "$hostd/$host_name.csr" "$hostd/$host_name.cer"
}

cm:sign:overwrite_check() {
	local certfile="$1"; shift
	
	[[ -f "$certfile" ]] || return 0

	askuser:confirm "${CYEL}Overwrite '$certfile'?$CDEF" || out:fail "Abort."

	rm "$certfile" || out:fail "Could not remove '$certfile'"
}


files:ensure_file() {
	local target="$1"; shift
	local tdir="$(dirname "$target")"

	[[ -d "$tdir" ]] || mkdir -p "$tdir"

	[[ -f "$target" ]] || echo -n "$*" > "$target"
}

### New registered host Usage:new-host
#
# Create a new stored host for certfiying
#
# Generates a key + CSR pair stored against the name
#
# 	certmaker new host HOST
#
###/doc

cm:host:new-host() {
	cm:helpcheck new-host "$@"

	if [[ -z "$*" ]]; then
		out:fail "You need to specify a name for the host configuration. Try adding '--help'"
	fi

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ "$myhost" =~ ^[a-zA-Z0-9_.-]+$ ]] || out:fail "Host name can only contain letters, numbers, underscore, period and dash."

	[[ ! -d "$myhostd" ]] || out:fail "Host '$myhost' already exists."

	mkdir -p "$myhostd"

	cm:template host "$myhostd/$myhost.cnf"
}
### New entity Usage:new
#
# Create a new Certificate Authority, or Host
#
#   certmaker new host HOSTNAME
#
#   certmaker new ca CACONF
#
# You can generate a CACONF file with
#
#   certmaker template ca [CACONF]
#
###/doc

cm:new() {
    cm:helpcheck new "$@"

	local target="$1"; shift

	case "$target" in
	ca)
		cm:ca:new-ca "$@"
		;;
	host)
		cm:host:new-host "$@"
		;;
	*)
		out:fail "Unknown target for new: '$target'"
		;;
	esac
}
### CSR Regenration Usage:renew
#
# (Re-)generate key for the host or config.
#
#	certmaker renew key CONFIG [KEYFILE]
#	certmaker renew key HOST
#
# (Re-)generate CSR for the host or key+config file pair
#
#	certmaker renew csr KEYFILE CONFIG [CSRFILE]
#	certmaker renew csr HOST
#
###/doc

cm:renew() {
    cm:helpcheck renew "$@"

    local rtype="${1:-}" ; shift || out:fail "Specify renewal type"
    local filehost="${1:-}" ; shift || out:fail "Specify target file or host"

    case "$rtype" in
    csr|key)
        if [[ -f "$filehost" ]]; then
            cm:renew:${rtype}-file "$filehost" "$@"
        else
            cm:renew:${rtype}-host "$filehost" "$@"
        fi
        ;;
    *)
        out:fail "Unknown renewal type '$rtype'"
        ;;
    esac
}

cm:renew:key-file() {
    local config keyfile

    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"
    keyfile="${1:-}"; shift || {
        keyfile="${config%.*}.key"
    }

    :: openssl genrsa -out "$keyfile" "$keysize" -config "$config"
}

cm:renew:key-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:key-file "$hostd/${host_name}.cnf" "$hostd/${host_name}.key"
}

cm:renew:csr-file() {
    local keyfile csrfile config
    keyfile="${1:-}"; shift || out:fail "Specify an input key file"
    config="${1:-}"; shift  || out:fail "Specify an OpenSSL config file"

    csrfile="${1:-}"; shift || {
        csrfile="${keyfile%.*}.csr"
    }

    :: openssl req -new -key "$keyfile" -out "$csrfile" -config "$config"
}

cm:renew:csr-host() {
    local host_name hostd
    host_name="${1:-}" ; shift || out:fail "Specify a host profile name"

    hostd="$hoststore/$host_name"
    [[ -d "$hostd" ]] || out:fail "No such host profile [$host_name]"

    cm:renew:csr-file "$hostd/${host_name}.key" "$hostd/${host_name}.cnf" "$hostd/${host_name}.csr"
}
cm:paths:_dispatch() {
    . <(args:use:local ?action ?host_name -- "$@") ; 
    if [[ -z "$action" ]]; then
        cm:paths:list
        return
    fi

    if [[ "$action" = "tgz" ]]; then
        cm:paths:give-tgz "$host_name" "$@"

    elif [[ "$action" = "show" ]]; then
        cm:paths:show "$host_name"
    else
        out:fail "Unknown action - try 'tgz HOSTNAME [TARNAME]' or 'show HOSTNAME'"
    fi
}

cm:paths:show() {
    . <(args:use:local host_name -- "$@") ; 
    local hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "Unknown host profile '$host_name'"

    ls "$hostd/$host_name."{key,cer}
}

cm:paths:list() {
    find "$hoststore" -name '*.cnf' -exec dirname {} \; | sed "s|$hoststore/||"
}

cm:paths:give-tgz() {
    . <(args:use:local host_name ?tarname -- "$@") ; 
    local hostd="$hoststore/$host_name"

    [[ -d "$hostd" ]] || out:fail "Unknown host profile '$host_name'"

    if [[ -z "$tarname" ]]; then
        tarname=./"$host_name-certkey.tgz"
    fi

    ( set -x
    tar czf "$tarname" -C "$hostd" "$host_name.cer" "$host_name.key"
    )
}
### Quick mode Usage:quick
#
# Set up a base configuration for host certificates; don't add any `DNS.*` entries yet
#
#    certmaker quick --edit
#
# Once you have a base configuration, you can create any number of individual hosts
#
#   certmaker quick PROFILENAME DOMAINS ...
#
# The profile name is a name for the store of the config, key, CSR and certificate files.
#
# DOMAINS ... is only required when first creating the profile ; to subsequently edit the domains the certificate will certify for, run
#
#   certmaker edit PROFILENAME
#
#
###/doc

cm:quick() {
    cm:helpcheck quick "$@"

    if [[ "$1" = "--edit" ]]; then
        cm:quick:edit_template

    else
        cm:quick:host "$@"
    fi
}

cm:quick:edit_template() {
    local quick_template
    quick_template="$hoststore/quick.cnf"
    if [[ ! -f "$quick_template" ]]; then
        cm:template host "$quick_template"
    fi

    cm:util:edit "$quick_template"
}

cm:quick:host() {
    local host_name
    host_name="${1:-}"; shift || out:fail "Specify a host name"

    cm:quick:ensure_host "$host_name" "$@"

    cm:quick:ensure_key "$host_name"
    cm:renew:csr-host "$host_name"

    cm:sign:host "$host_name"

    # Echo the colour byte to stderr
    # but the keys to stdout
    # in case user is grepping for the files
    echo -n "$CBBLU" >&2
    echo "$(cm:paths:show "$host_name")"
    echo -n "$CDEF" >&2
}

cm:quick:ensure_host() {
    local host_name hostd hostconf quick_template x
    host_name="${1:-}"; shift
    hostd="$hoststore/$host_name"
    hostconf="$hostd/$host_name.cnf"

    quick_template="$hoststore/quick.cnf"
    [[ -f "$quick_template" ]] || out:fail "Quick template not yet set - run 'certmaker quick --edit' to create a global template first"

    if [[ ! -f "$hostconf" ]]; then

        askuser:confirm "Create host '$host_name' ?"
        [[ -n "$*" ]] || out:fail "You need to also specify domains to add."

        cm:host:new-host "$host_name"
        cp "$quick_template" "$hostconf"

        cm:quick:enumerate "$@" >> "$hostconf"

        cm:edit:host "$host_name"
    fi
}

cm:quick:enumerate() {
    for x in $(seq 1 $#); do
        echo "DNS.$x = $1"
        shift
    done
}

cm:quick:ensure_key() {
    local host_name hostd hostconf
    host_name="${1:-}"; shift
    hostd="$hoststore/$host_name"

    if [[ ! -f "$hostd/$host_name.key" ]]; then
        cm:renew:key-host "$host_name"
    fi
}

### Edit host config Usage:edit
#
#	certmaker edit HOST
#
# Edit the SSL config for the registered host
#
###/doc

cm:edit() {
	cm:helpcheck edit "$@"

    if [[ "$1" = --ca ]]; then
        cm:util:edit "$castore/authority.cnf"
    else
        cm:edit:host "$@"
    fi
}

cm:edit:host() {

	local myhost myhostd
	myhost="$1"; shift
	myhostd="$hoststore/$myhost"

	[[ -d "$myhostd" ]] || out:fail "Host '$myhost' does not exist."

    cm:util:edit "$myhostd/$myhost.cnf"
}

### certmaker csr NAME [FQDN ...] Usage:makecsr
# 
# Create a new CSR, generating a config and key file if necessary
#
###/doc

cm:csr() {
	local name

	cm:helpcheck makecsr "$@"

	name="${1:-}"; shift || out:fail "Specify the base name to create e.g. 'mysite'"

	[[ -f "$name.cnf" ]] || {
		[[ -n "$*" ]] || out:fail "Specify the websites to certify for (FQDNs, e.g. 'mysite.company.net')"

		cm:template host "$name.cnf"
		cm:quick:enumerate "$@" >> "$name.cnf"
		cm:util:edit "$name.cnf"
	}
	[[ -f "$name.key" ]] || cm:renew key "$name.cnf" "$name.key"
	
	cm:renew csr "$name.key" "$name.cnf" "$name.csr"
}
#!/bin/bash

##bash-libs: patterns.sh @ bf310b32 (1.4.1)

### Useful patterns Usage:bbuild
#
# Some useful regex patterns, exported as environment variables.
#
# They are not foolproof, and you are encouraged to improve upon them.
#
# $PAT_blank - detects whether an entire line is empty or whitespace
# $PAT_comment - detects whether is a line is a script comment (assumes '#' as the comment marker)
# $PAT_num - detects whether the string is an integer number in its entirety
# $PAT_cvar - detects if the string is a valid C variable name
# $PAT_filename - detects if the string is a safe UNIX or Windows file name;
#   does not allow presence of whitespace or special characters aside from '_', '.', '-'
# $PAT_email - simple heuristic to determine whether a string looks like a valid email address
#
###/doc

export PAT_blank='^\s*$'
export PAT_comment='^\s*(#.*)?$'
export PAT_num='^[0-9]+$'
export PAT_cvar='^[a-zA-Z_][a-zA-Z0-9_]*$'
export PAT_filename='^[a-zA-Z0-9_.-]$'
export PAT_email="$PAT_filename@$PAT_filename.$PAT_cvar"

##bash-libs: args.sh @ bf310b32 (1.4.1)

### args Usage:bbuild
#
# An arguments handling utility.
#
###/doc

### args:get TOKEN ARGS ... Usage:bbuild
#
# Given a TOKEN, find the argument value
#
# Typically called with the parent's arguments
#
# 	args:get --key "$@"
# 	args:get -k "$@"
#
# If TOKEN is an int, returns the argument at that index (starts at 1, negative numbers count from end backwards)
#
# If TOKEN starts with two dashes ("--"), expect the value to be supplied after an equal sign
#
# 	--token=desired_value
#
# If TOKEN starts with a single dash, and is a letter or a number, expect the value to be the following token
#
# 	-t desired_value
#
# Returns 1 if could not find anything appropriate.
#
###/doc

args:get() {
    local seek="$1"; shift || :

    if [[ "$seek" =~ $PAT_num ]]; then
        local arguments=("$@")

        # Get the index starting at 1
        local n=$((seek-1))
        # but do not affect wrap-arounds
        [[ "$n" -ge 0 ]] || n=$((n+1))

        echo "${arguments[$n]}"

    elif [[ "$seek" =~ ^--.+ ]]; then
        args:get_long "$seek" "$@"

    elif [[ "$seek" =~ ^-[a-zA-Z0-9]$ ]]; then
        args:get_short "$seek" "$@"

    else
        return 1
    fi
}

args:get_short() {
    local token="$1"; shift || :
    while [[ -n "$*" ]]; do
        local item="$1"; shift || :

        if [[ "$item" = "$token" ]]; then
            echo "$1"
            return 0
        fi
    done
    return 1
}

args:get_long() {
    local token="$1"; shift || :
    local tokenpat="^$token=(.*)$"

    for item in "$@"; do
        if [[ "$item" =~ $tokenpat ]]; then
            echo "${BASH_REMATCH[1]}"
            return 0
        fi
    done
    return 1
}

### args:has TOKEN ARGS ... Usage:bbuild
#
# Determines whether TOKEN is present on its own in ARGS
#
# Typically called with the parent's arguments
#
# 	args:has thing "$@"
#
# Returns 0 on success for example
#
# 	args:has thing "one" "thing" "or" "another"
#
# Returns 1 on failure for example
#
# 	args:has thing "one thing" "or another"
#
# "one thing" is not a valid match for "thing" as a token.
#
###/doc

args:has() {
    local token="$1"; shift || :
    for item in "$@"; do
        if [[ "$token" = "$item" ]]; then
            return 0
        fi
    done
    return 1
}

### args:after TOKEN ARGS ... Usage:bbuild
#
# Return all tokens after TOKEN via the RETARR_ARGSAFTER
#
#    myargs=(one two -- three "four and" five)
# 	args:after -- "${myargs[@]}"
#
# 	for a in "${RETARR_ARGSAFTER}"; do
# 		echo "$a"
# 	done
#
# The above prints
#
# 	three
# 	four and
# 	five
#
###/doc

args:after() {
    local token="$1"; shift || :
    
    local current_token="$1"; shift || :
    while [[ "$#" -gt 0 ]] && [[ "$current_token" != "$token" ]]; do
        current_token="$1"; shift || :
    done

    RETARR_ARGSAFTER=("$@")
}

### args:use ARGNAMES ... -- ARGVALUES ... Usage:bbuild
# 
# Consume arguments into named global variables.
#
# If not enough argument values are found, the first named variable that failed to be assigned is printed as error
#
# ARGNAMES prefixed with '?' do not trigger an error
#
# Example:
#
#   #%include out.sh
#   #%include args.sh
#
#   get_parameters() {
#       . <(args:use INFILE OUTFILE ?comment -- "$@")
#
#       [[ -f "$INFILE" ]]  || out:fail "Input file '$INFILE' does not exist"
#       [[ -f "$OUTFILE" ]] || out:fail "Output file '$OUTFILE' does not exist"
#
#       [[ -z "$comment" ]] || echo "Note: $comment"
#   }
#
#   main() {
#       get_parameters "$@"
#
#       echo "$INFILE will be converted to $OUTFILE"
#   }
#
#   main "$@"
#
###/doc
args:use() {
    local argname arglist undef_f
    arglist=(:)
    for argname in "$@"; do
        [[ "$argname" != -- ]] || break
        [[ "$argname" =~ ^\??[0-9a-zA-Z_]+$ ]] || out:fail "Internal: Not a valid argument name '$argname'"

        arglist+=("$argname")
    done

    for argname in "${arglist[@]:1}"; do
        if [[ "$argname" =~ ^\? ]]; then
            argname="${argname:1}"
            undef_f=":"
        else
            undef_f="out:fail \"Internal : could not get '$argname'\""
        fi

        echo "$ARGSLIB_scope $argname=\"\${1:-}\"; shift || $undef_f"
    done
}


### args:use:local ARGNAMES ... -- ARGVALUES ... Usage:bbuild
# 
# Consume arguments into named variables. You need to use process subtitution and sourcing
#   to call the function, so that it affects the scope in your function.
#
# If not enough argument values are found, the named variable that failed to be assigned is printed as error
#
# Example:
#
#   #%include out.sh
#   #%include args.sh
#
#   person() {
#       . <(args:use:local name email -- "$@")
#
#       echo "$name <$email>"
#
#       # $1 and $2 have been consumed into $name and $email
#       # The rest remains available in $* :
#       
#       echo "Additional notes: $*"
#   }
#
#   person "Jo Smith" "jsmith@exam0ple.com" Some details
#
###/doc
args:use:local() {
    ARGSLIB_scope=local args:use "$@"
}

set -euo pipefail

### JKS manipulator Usage:jksm
#Manipulate a Java Key Store or PKCS12 store using 'keytool' (which has too many options to remember for infrequent use ...)
#
#There are typically 3 options to the jks subcommand:
#
#-k KEYSTORE : the keystore to operate on
#-a ALIAS : the alias to use for the operation, where appropriate
#-f TARGETFILE : the file that will be read from or written to, changing depending on the command
#
#
#certmaker jks generate -k KEYSTORE -a ALIAS
#
#    Create a new key store, with a key alias
#
#
#certmaker jks csr -k KEYSTORE -a ALIAS -f CSRFILE
#
#    Derive a CSR from the KEYSTORE from the ALIAS entry
#
#
#certmaker jks add-ca -k KEYSTORE -a ALIAS -f CACERT
#
#    Add a CA certificate file CACERT to the KEYSTORE under ALIAS
#
#
#certmaker jks add-cert -k KEYSTORE -a ALIAS -f CERT
#
#    Add a certificate file CERT to the KEYSTORE under ALIAS
#
#
#certmaker jks add-key -k KEYSTORE -a ALIAS -f KEYFILE
#
#    Add a key file KEYFILE to the KEYSTORE under ALIAS
#
#    The key file must be either in PEM or PKCS12 format
#    If in PEM format, a similarly named CER file must accompany it
#
#    e.g. "import/application.key" needs a corresponding "import/application.cer" file
#
#
#certmaker jks delete -k KEYSTORE -a ALIAS
#
#    Delete an alias ALIAS from the KEYSTORE
#
#
#certmaker jks view -k KEYSTORE [-a ALIAS]
#
#    View the contents of the keystore, or optionally the contents under the keystore alias
#
#certmaker jks rename -k KEYSTORE -a OLDALIAS:NEWALIAS
#
#    Rename an old alias to a new one by cloning the old to new, and deleting the old one.
###/doc

jks:dispatch() {
    action="$1"; shift

    case "$action" in
        generate)
            jks:gen ;;

        csr)
            jks:csr ;;

        add-ca)
            jks:add:cacert ;;

        add-cert)
            jks:add:cert ;;

        add-key)
            jks:add:key ;;

        delete)
            jks:delete ;;

        view)
            jks:view ;;
        rename)
            jks:rename ;;

        *)
            out:fail "Unknown action '$action'" ;;
    esac
}

jks:args() {
    local flag

    for flag in "$@"
    do
        case "$flag" in
        -k)
            keystore="$(args:get -k "${SCRIPT_ARGS[@]}")"
            ;;
        -f)
            targetfile="$(args:get -f "${SCRIPT_ARGS[@]}")"
            ;;
        -a)
            ksalias="$(args:get -a "${SCRIPT_ARGS[@]}")"
            ;;

        esac
    done
}

jks:convert_key() {
    local certfile="${targetfile%.*}.cer"
    [[ -f "$certfile" ]] || out:fail "You must provide the certificate file as $certfile"
    out:info "Combining $targetfile and $certfile"

    # FIXME this generates error "unable to write 'random state'" even though output/result looks fine...
    openssl pkcs12 -export -inkey "$targetfile" -in "$certfile"
}

jks:gen() {
    jks:args -k || out:fail "Keystore is required"
    jks:args -f || :

    if [[ -z "${targetfile:-}" ]]; then
        jks:args -a || out:fail "Alias is required"
        keytool -genkey -alias "$ksalias" -keyalg RSA -keystore "$keystore" -deststoretype pkcs12 # FIXME This is still generateing JKS store??
    else
        jks:convert_key > "$keystore" # provided through $targetfile
    fi

}

jks:csr() {
    jks:args -k -a -f || out:fail "Keystore, Alias and Output CSR file are required"
    keytool -certreq -keyalg RSA -alias "$ksalias" -keystore "$keystore" -file "$targetfile"
}

jks:add:cacert() {
    jks:args -k -a -f || out:fail "Keystore, Alias and CA cert are required"
    keytool -import -alias "$ksalias" -keystore "$keystore" -trustcacerts -file "$targetfile"
}

jks:add:cert() {
    jks:args -k -a -f || out:fail "Keystore, Alias and Cert are required"
    keytool -import -alias "$ksalias" -keystore "$keystore" -file "$targetfile"
}

jks:ensure_pkcs12() {
    if [[ "$targetfile" =~ \.*\.p12 ]]; then
        cat "$targetfile"

    elif grep -qP "PRIVATE KEY" "$targetfile"; then
        out:warn "You provided PEM files - we will create a temporary store in which to put the key and certificate"
        jks:convert_key

        out:warn "You will be asked for the destination store password (your keystore) and the source store password (the intermediate store) to complete the import."
    else
        out:fail "PEM or PKCS12 file required!"
    fi
}

jks:cleanup() {
    if [[ -f "${p12datafile:-}" ]]; then
        rm "$p12datafile"
    fi
}

jks:add:key() {
    # Annoyingly, keytool needs a PKCS12 store for importing - it can't simply add a key
    jks:args -k -f || out:fail "Keystore and Key file ({.key + .cer} or .p12) are required"

    trap jks:cleanup EXIT

    p12datafile="$(mktemp XXXX.p12)"
    jks:ensure_pkcs12 > "$p12datafile" # Should fail on its own here if bad file

    keytool -importkeystore -srckeystore "$p12datafile" -destkeystore "$keystore" -srcstoretype pkcs12

    jks:cleanup
}

jks:delete() {
    jks:args -k -a || out:fail "Keystore and Alias are required"
    keytool -delete -alias "$ksalias" -keystore "$keystore"
}

jks:view() {
    jks:args -k || out:fail "Keystore is required"
    jks:args -a || :
    if [[ -n "${ksalias:-}" ]]; then
        keytool -list -alias "$ksalias" -keystore "$keystore"

    else
        keytool -list -keystore "$keystore"
    fi
}

jks:rename() {
    jks:args -k -a || out:fail "Keystore required ; Alias required as \`oldalias:newalias\`"

    local oldalias="${ksalias%:*}"
    local newalias="${ksalias#*:}"

    out:warn "We'll clone the old alias to a new name, then delete the old alias."
    ( set -ex
        keytool -keyclone -alias "$oldalias" -dest "$newalias" -keystore "$keystore"
        keytool -delete -alias "$oldalias" -keystore "$keystore"
    )
}

jksm:main() {
    if [[ -z "$*" ]] || [[ "$*" =~ --help ]]; then
        autohelp:print jksm
        exit
    fi

    bincheck:has keytool || out:fail "'keytool' is not installed - try installing openjdk-8-jre-headless"
    bincheck:has openssl || out:warn "'openssl' is not installed - key conversions will fail"

    SCRIPT_ARGS=("$@")
    jks:dispatch "$@"
}

cm:main() {
    # Do not autohelp:check here, as it would override sub-topic help
    [[ -n "$*" ]] || {
        autohelp:print
        exit 0
    }
    action="$1"; shift || :

    # Config-less modules
    case "$action" in
        view|fetch)
            cert-getter:main "$action" "$@"
            return
            ;;
        jks)
            jksm:main "$@"
            return
            ;;
        help|--help)
            cm:guide
            return 0
            ;;
    esac

    cm:config:load_config
    cm:checkuser

    case "$action" in
        template)
            cm:template "$@"
            ;;
	csr)
		cm:csr "$@"
		;;
        new)
            cm:new "$@"
            ;;
        edit)
            cm:edit "$@"
            ;;
        sign)
            cm:sign "$@"
            ;;
        renew)
            cm:renew "$@"
            ;;
        paths)
            cm:paths:_dispatch "$@"
            ;;
        quick)
            cm:quick "$@"
            ;;
        *)
            autohelp:print
            out:fail "Unknown action $action"
            ;;
    esac
}

cm:checkuser() {
    local iam=$(whoami)

    if [[ "$cmuser" = root ]] && [[ "$iam" != 'root' ]]; then
        out:fail "CertMaker is installed for the root user. Only the root user can use it now."
    fi

    [[ "$cmuser" = "$iam" ]] || {
        out:warn "Loaded Certmaker config was installed for '$cmuser'."
        askuser:confirm "Continue?"
    }
}

cm:helpcheck() {

    local section="$1"; shift

    if [[ "$*" =~ --help ]] || [[ -z "$*" ]]; then
        autohelp:print "$section"
        exit 0
    fi

    return 0
}

cm:main "$@"
